<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Supremes</name>
    </assembly>
    <members>
        <member name="T:Supremes.Dcsoup">
            <summary>
            The core public access point to the Dcsoup functionality.
            </summary>
            <author>Jonathan Hedley</author>
        </member>
        <member name="M:Supremes.Dcsoup.Parse(System.Net.Http.HttpResponseMessage)">
            <summary>
            Parse HTML into a Document.
            </summary>
            <param name="self">
            The input <see cref="T:System.Net.Http.HttpResponseMessage"/>,
            which acts as the <b>this</b> instance for the extension method.
            </param>
            <returns>sane HTML document</returns>
        </member>
        <member name="M:Supremes.Dcsoup.Parse(System.String,System.String)">
            <summary>
            Parse HTML into a Document.
            </summary>
            <remarks>
            The parser will make a sensible, balanced document tree out of any HTML.
            </remarks>
            <param name="html">HTML to parse</param>
            <param name="baseUri">
            The URL where the HTML was retrieved from. Used to resolve relative URLs to absolute URLs, that occur
            before the HTML declares a
            <c>&lt;base href&gt;</c>
            tag.
            </param>
            <returns>sane HTML</returns>
        </member>
        <member name="M:Supremes.Dcsoup.Parse(System.String,System.String,Supremes.Parsers.Parser)">
            <summary>
            Parse HTML into a Document, using the provided Parser.
            </summary>
            <remarks>
            You can provide an alternate parser, such as a simple XML
            (non-HTML) parser.
            </remarks>
            <param name="html">HTML to parse</param>
            <param name="baseUri">
            The URL where the HTML was retrieved from. Used to resolve relative URLs to absolute URLs, that occur
            before the HTML declares a
            <c>&lt;base href&gt;</c>
            tag.
            </param>
            <param name="parser">
            alternate
            <see cref="P:Supremes.Parsers.Parser.XmlParser">parser</see>
            to use.
            </param>
            <returns>sane HTML</returns>
        </member>
        <member name="M:Supremes.Dcsoup.Parse(System.String)">
            <summary>
            Parse HTML into a Document.
            </summary>
            <remarks>
            As no base URI is specified, absolute URL detection relies on the HTML including a
            <c>&lt;base href&gt;</c>
            tag.
            </remarks>
            <param name="html">HTML to parse</param>
            <returns>sane HTML</returns>
            <seealso cref="M:Supremes.Dcsoup.Parse(System.String,System.String)">Parse(string, string)</seealso>
        </member>
        <member name="M:Supremes.Dcsoup.ParseFile(System.String,System.String,System.String)">
            <summary>
            Parse the contents of a file as HTML.
            </summary>
            <param name="in">file to load HTML from</param>
            <param name="charsetName">
            (optional) character set of file contents. Set to
            <c>null</c>
            to determine from
            <c>http-equiv</c>
            meta tag, if present, or fall back to
            <c>UTF-8</c>
            (which is often safe to do).
            </param>
            <param name="baseUri">
            The URL where the HTML was retrieved from, to resolve relative links against.
            </param>
            <returns>sane HTML</returns>
            <exception cref="T:System.IO.IOException">
            if the file could not be found, or read, or if the charsetName is invalid.
            </exception>
        </member>
        <member name="M:Supremes.Dcsoup.ParseFile(System.String,System.String)">
            <summary>
            Parse the contents of a file as HTML.
            </summary>
            <remarks>
            The location of the file is used as the base URI to qualify relative URLs.
            </remarks>
            <param name="in">file to load HTML from</param>
            <param name="charsetName">
            (optional) character set of file contents. Set to
            <c>null</c>
            to determine from
            <c>http-equiv</c>
            meta tag, if present, or fall back to
            <c>UTF-8</c>
            (which is often safe to do).
            </param>
            <returns>sane HTML</returns>
            <exception cref="T:System.IO.IOException">
            if the file could not be found, or read, or if the charsetName is invalid.
            </exception>
            <seealso cref="M:Supremes.Dcsoup.ParseFile(System.String,System.String,System.String)">ParseFile(string, string, string)</seealso>
        </member>
        <member name="M:Supremes.Dcsoup.Parse(System.IO.Stream,System.String,System.String)">
            <summary>
            Read an input stream, and parse it to a Document.
            </summary>
            <param name="in">input stream to read. Make sure to close it after parsing.</param>
            <param name="charsetName">
            (optional) character set of file contents. Set to
            <c>null</c>
            to determine from
            <c>http-equiv</c>
            meta tag, if present, or fall back to
            <c>UTF-8</c>
            (which is often safe to do).
            </param>
            <param name="baseUri">
            The URL where the HTML was retrieved from, to resolve relative links against.
            </param>
            <returns>sane HTML</returns>
            <exception cref="T:System.IO.IOException">
            if the file could not be found, or read, or if the charsetName is invalid.
            </exception>
        </member>
        <member name="M:Supremes.Dcsoup.Parse(System.IO.Stream,System.String,System.String,Supremes.Parsers.Parser)">
            <summary>
            Read an input stream, and parse it to a Document.
            </summary>
            <remarks>
            You can provide an alternate parser, such as a simple XML
            (non-HTML) parser.
            </remarks>
            <param name="in">input stream to read. Make sure to close it after parsing.</param>
            <param name="charsetName">
            (optional) character set of file contents. Set to
            <c>null</c>
            to determine from
            <c>http-equiv</c>
            meta tag, if present, or fall back to
            <c>UTF-8</c>
            (which is often safe to do).
            </param>
            <param name="baseUri">
            The URL where the HTML was retrieved from, to resolve relative links against.
            </param>
            <param name="parser">
            alternate
            <see cref="P:Supremes.Parsers.Parser.XmlParser">parser</see>
            to use.
            </param>
            <returns>sane HTML</returns>
            <exception cref="T:System.IO.IOException">
            if the file could not be found, or read, or if the charsetName is invalid.
            </exception>
        </member>
        <member name="M:Supremes.Dcsoup.ParseBodyFragment(System.String,System.String)">
            <summary>
            Parse a fragment of HTML, with the assumption that it forms the
            <c>body</c>
            of the HTML.
            </summary>
            <param name="bodyHtml">body HTML fragment</param>
            <param name="baseUri">URL to resolve relative URLs against.</param>
            <returns>sane HTML document</returns>
            <seealso cref="P:Supremes.Nodes.Document.Body">Supremes.Nodes.Document.Body</seealso>
        </member>
        <member name="M:Supremes.Dcsoup.ParseBodyFragment(System.String)">
            <summary>
            Parse a fragment of HTML, with the assumption that it forms the
            <c>body</c>
            of the HTML.
            </summary>
            <param name="bodyHtml">body HTML fragment</param>
            <returns>sane HTML document</returns>
            <seealso cref="P:Supremes.Nodes.Document.Body">Supremes.Nodes.Document.Body</seealso>
        </member>
        <member name="M:Supremes.Dcsoup.Parse(System.Uri,System.Int32)">
            <summary>
            Fetch a URL, and parse it as HTML.
            </summary>
            <remarks>
            <para>
            Provided for compatibility.
            </para>
            <para>
            The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to
            <c>UTF-8</c>
            .
            </para>
            </remarks>
            <param name="url">
            URL to fetch (with a GET). The protocol must be
            <c>http</c>
            or
            <c>https</c>
            .
            </param>
            <param name="timeoutMillis">
            Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.
            </param>
            <returns>The parsed HTML.</returns>
            <exception cref="T:System.UriFormatException">
            if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed
            </exception>
            <exception cref="T:System.Exception">
            (HttpStatusException)if the response is not OK and HTTP response errors are not ignored
            (UnsupportedMimeTypeException)if the response mime type is not supported and those errors are not ignored
            </exception>
            <exception cref="T:System.TimeoutException">if the connection times out</exception>
            <exception cref="T:System.IO.IOException">if a connection or read error occurs</exception>
        </member>
        <member name="M:Supremes.Dcsoup.Clean(System.String,System.String,Supremes.Safety.Whitelist)">
            <summary>
            Get safe HTML from untrusted input HTML,
            by parsing input HTML and filtering it through a white-list of permitted
            tags and attributes.
            </summary>
            <param name="bodyHtml">input untrusted HTML (body fragment)</param>
            <param name="baseUri">URL to resolve relative URLs against</param>
            <param name="whitelist">white-list of permitted HTML elements</param>
            <returns>safe HTML (body fragment)</returns>
            <seealso cref="M:Supremes.Safety.Cleaner.Clean(Supremes.Nodes.Document)">
            Supremes.Safety.Cleaner.Clean(Supremes.Nodes.Document)
            </seealso>
        </member>
        <member name="M:Supremes.Dcsoup.Clean(System.String,Supremes.Safety.Whitelist)">
            <summary>
            Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of permitted
            tags and attributes.
            </summary>
            <param name="bodyHtml">input untrusted HTML (body fragment)</param>
            <param name="whitelist">white-list of permitted HTML elements</param>
            <returns>safe HTML (body fragment)</returns>
            <seealso cref="M:Supremes.Safety.Cleaner.Clean(Supremes.Nodes.Document)">
            Supremes.Safety.Cleaner.Clean(Supremes.Nodes.Document)
            </seealso>
        </member>
        <member name="M:Supremes.Dcsoup.Clean(System.String,System.String,Supremes.Safety.Whitelist,Supremes.Nodes.DocumentOutputSettings)">
            <summary>
            Get safe HTML from untrusted input HTML,
            by parsing input HTML and filtering it through a white-list of permitted tags and attributes.
            </summary>
            <param name="bodyHtml">input untrusted HTML (body fragment)</param>
            <param name="baseUri">URL to resolve relative URLs against</param>
            <param name="whitelist">white-list of permitted HTML elements</param>
            <param name="outputSettings">document output settings; use to control pretty-printing and entity escape modes</param>
            <returns>safe HTML (body fragment)</returns>
            <seealso cref="M:Supremes.Safety.Cleaner.Clean(Supremes.Nodes.Document)">Supremes.Safety.Cleaner.Clean(Supremes.Nodes.Document)</seealso>
        </member>
        <member name="M:Supremes.Dcsoup.IsValid(System.String,Supremes.Safety.Whitelist)">
            <summary>
            Test if the input HTML has only tags and attributes allowed by the Whitelist.
            </summary>
            <remarks>
            Useful for form validation. The input HTML should
            still be run through the cleaner to set up enforced attributes, and to tidy the output.
            </remarks>
            <param name="bodyHtml">HTML to test</param>
            <param name="whitelist">whitelist to test against</param>
            <returns>true if no tags or attributes were removed; false otherwise</returns>
            <seealso cref="M:Supremes.Dcsoup.Clean(System.String,Supremes.Safety.Whitelist)"></seealso>
        </member>
        <member name="T:Supremes.Fluent.FluentUtility">
            <summary>
            Provides a set of static methods for jQuery-like method chainings.
            </summary>
        </member>
        <member name="M:Supremes.Fluent.FluentUtility.WholeData(Supremes.Nodes.DataNode,System.String)">
            <summary>
            Set the data contents of the specified node, and returns the node itself.
            </summary>
            <param name="self">
            The input <see cref="T:Supremes.Nodes.DataNode"/>,
            which acts as the <b>this</b> instance for the extension method.
            </param>
            <param name="data">unencoded data</param>
            <returns>The input <see cref="T:Supremes.Nodes.DataNode"/>, for method chaining.</returns>
            <seealso cref="P:Supremes.Nodes.DataNode.WholeData">DataNode.WholeData</seealso>
        </member>
        <member name="M:Supremes.Fluent.FluentUtility.EscapeMode(Supremes.Nodes.DocumentOutputSettings,Supremes.Nodes.DocumentEscapeMode)">
            <summary>
            Set the current HTML escape mode of the specified document settings, and returns the document settings itself.
            </summary>
            <param name="self">
            The input <see cref="T:Supremes.Nodes.DocumentOutputSettings"/>,
            which acts as the <b>this</b> instance for the extension method.
            </param>
            <param name="escapeMode">the new escape mode to use</param>
            <returns>The input <see cref="T:Supremes.Nodes.DocumentOutputSettings"/>, for method chaining.</returns>
            <seealso cref="P:Supremes.Nodes.DocumentOutputSettings.EscapeMode">DocumentOutputSettings.EscapeMode</seealso>
        </member>
        <member name="M:Supremes.Fluent.FluentUtility.Charset(Supremes.Nodes.DocumentOutputSettings,System.Text.Encoding)">
            <summary>
            Set the current output charset of the specified document settings, and returns the document settings itself.
            </summary>
            <param name="self">
            The input <see cref="T:Supremes.Nodes.DocumentOutputSettings"/>,
            which acts as the <b>this</b> instance for the extension method.
            </param>
            <param name="charset">the new charset to use</param>
            <returns>The input <see cref="T:Supremes.Nodes.DocumentOutputSettings"/>, for method chaining.</returns>
            <seealso cref="P:Supremes.Nodes.DocumentOutputSettings.Charset">DocumentOutputSettings.Charset</seealso>
        </member>
        <member name="M:Supremes.Fluent.FluentUtility.Charset(Supremes.Nodes.DocumentOutputSettings,System.String)">
            <summary>
            Set the current output charset of the specified document settings, and returns the document settings itself.
            </summary>
            <param name="self">
            The input <see cref="T:Supremes.Nodes.DocumentOutputSettings"/>,
            which acts as the <b>this</b> instance for the extension method.
            </param>
            <param name="charset">the new charset name to use</param>
            <returns>The input <see cref="T:Supremes.Nodes.DocumentOutputSettings"/>, for method chaining.</returns>
            <seealso cref="P:Supremes.Nodes.DocumentOutputSettings.Charset">DocumentOutputSettings.Charset</seealso>
        </member>
        <member name="M:Supremes.Fluent.FluentUtility.Syntax(Supremes.Nodes.DocumentOutputSettings,Supremes.Nodes.DocumentSyntax)">
            <summary>
            Set the current output syntax of the specified document settings, and returns the document settings itself.
            </summary>
            <param name="self">
            The input <see cref="T:Supremes.Nodes.DocumentOutputSettings"/>,
            which acts as the <b>this</b> instance for the extension method.
            </param>
            <param name="syntax">the new syntax to use</param>
            <returns>The input <see cref="T:Supremes.Nodes.DocumentOutputSettings"/>, for method chaining.</returns>
            <seealso cref="P:Supremes.Nodes.DocumentOutputSettings.Syntax">DocumentOutputSettings.Syntax</seealso>
        </member>
        <member name="M:Supremes.Fluent.FluentUtility.PrettyPrint(Supremes.Nodes.DocumentOutputSettings,System.Boolean)">
            <summary>
            Set if pretty printing is enabled to the specified document settings, and returns the document settings itself.
            </summary>
            <param name="self">
            The input <see cref="T:Supremes.Nodes.DocumentOutputSettings"/>,
            which acts as the <b>this</b> instance for the extension method.
            </param>
            <param name="pretty">the new pretty print setting</param>
            <returns>The input <see cref="T:Supremes.Nodes.DocumentOutputSettings"/>, for method chaining.</returns>
            <seealso cref="P:Supremes.Nodes.DocumentOutputSettings.PrettyPrint">DocumentOutputSettings.PrettyPrint</seealso>
        </member>
        <member name="M:Supremes.Fluent.FluentUtility.Outline(Supremes.Nodes.DocumentOutputSettings,System.Boolean)">
            <summary>
            Set if outline mode is enabled to the specified document settings, and returns the document settings itself.
            </summary>
            <param name="self">
            The input <see cref="T:Supremes.Nodes.DocumentOutputSettings"/>,
            which acts as the <b>this</b> instance for the extension method.
            </param>
            <param name="outlineMode">the new outline mode</param>
            <returns>The input <see cref="T:Supremes.Nodes.DocumentOutputSettings"/>, for method chaining.</returns>
            <seealso cref="P:Supremes.Nodes.DocumentOutputSettings.Outline">DocumentOutputSettings.Outline</seealso>
        </member>
        <member name="M:Supremes.Fluent.FluentUtility.IndentAmount(Supremes.Nodes.DocumentOutputSettings,System.Int32)">
            <summary>
            Set the current tag indent amount of the specified document settings, used when pretty printing, and returns the document settings itself.
            </summary>
            <param name="self">
            The input <see cref="T:Supremes.Nodes.DocumentOutputSettings"/>,
            which acts as the <b>this</b> instance for the extension method.
            </param>
            <param name="indentAmount">number of spaces to use for indenting each level</param>
            <returns>The input <see cref="T:Supremes.Nodes.DocumentOutputSettings"/>, for method chaining.</returns>
            <seealso cref="P:Supremes.Nodes.DocumentOutputSettings.IndentAmount">DocumentOutputSettings.IndentAmount</seealso>
        </member>
        <member name="M:Supremes.Fluent.FluentUtility.Text(Supremes.Nodes.Document,System.String)">
            <summary>
            Set the combined text of the specified document and all its children, and returns the document itself.
            </summary>
            <param name="self">
            The input <see cref="T:Supremes.Nodes.Document"/>,
            which acts as the <b>this</b> instance for the extension method.
            </param>
            <param name="text">unencoded text</param>
            <returns>The input <see cref="T:Supremes.Nodes.Document"/>, for method chaining.</returns>
            <seealso cref="P:Supremes.Nodes.Document.Text">Document.Text</seealso>
        </member>
        <member name="M:Supremes.Fluent.FluentUtility.OutputSettings(Supremes.Nodes.Document,Supremes.Nodes.DocumentOutputSettings)">
            <summary>
            Set the specified document's current output settings, and returns the document itself.
            </summary>
            <param name="self">
            The input <see cref="T:Supremes.Nodes.Document"/>,
            which acts as the <b>this</b> instance for the extension method.
            </param>
            <param name="outputSettings">new output settings</param>
            <returns>The input <see cref="T:Supremes.Nodes.Document"/>, for method chaining.</returns>
            <seealso cref="P:Supremes.Nodes.Document.OutputSettings">Document.OutputSettings</seealso>
        </member>
        <member name="M:Supremes.Fluent.FluentUtility.QuirksMode(Supremes.Nodes.Document,Supremes.Nodes.DocumentQuirksMode)">
            <summary>
            Set the specified document's quirks mode, and returns the document itself.
            </summary>
            <param name="self">
            The input <see cref="T:Supremes.Nodes.Document"/>,
            which acts as the <b>this</b> instance for the extension method.
            </param>
            <param name="quirksMode">new quirks mode</param>
            <returns>The input <see cref="T:Supremes.Nodes.Document"/>, for method chaining.</returns>
            <seealso cref="P:Supremes.Nodes.Document.QuirksMode">Document.QuirksMode</seealso>
        </member>
        <member name="M:Supremes.Fluent.FluentUtility.TagName(Supremes.Nodes.Element,System.String)">
            <summary>
            Set the name of the tag for the specified element, and returns the element itself.
            </summary>
            <param name="self">
            The input <see cref="T:Supremes.Nodes.Element"/>,
            which acts as the <b>this</b> instance for the extension method.
            </param>
            <param name="tagName">the new tag name</param>
            <returns>The input <see cref="T:Supremes.Nodes.Element"/>, for method chaining.</returns>
            <seealso cref="P:Supremes.Nodes.Element.TagName">Element.TagName</seealso>
        </member>
        <member name="M:Supremes.Fluent.FluentUtility.ClassNames(Supremes.Nodes.Element,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Set all of the specified element's class names, and returns the element itself.
            </summary>
            <param name="self">
            The input <see cref="T:Supremes.Nodes.Element"/>,
            which acts as the <b>this</b> instance for the extension method.
            </param>
            <param name="classNames">the new set of classes</param>
            <returns>The input <see cref="T:Supremes.Nodes.Element"/>, for method chaining.</returns>
            <seealso cref="P:Supremes.Nodes.Element.ClassNames">Element.ClassNames</seealso>
        </member>
        <member name="M:Supremes.Fluent.FluentUtility.Val(Supremes.Nodes.Element,System.String)">
            <summary>
            Set the value of the specified form element (input, textarea, etc), and returns the element itself.
            </summary>
            <param name="self">
            The input <see cref="T:Supremes.Nodes.Element"/>,
            which acts as the <b>this</b> instance for the extension method.
            </param>
            <param name="value">the new value to set</param>
            <returns>The input <see cref="T:Supremes.Nodes.Element"/>, for method chaining.</returns>
            <seealso cref="P:Supremes.Nodes.Element.Val">Element.Val</seealso>
        </member>
        <member name="M:Supremes.Fluent.FluentUtility.Html(Supremes.Nodes.Element,System.String)">
            <summary>
            Set the specified element's inner HTML, and returns the element itself.
            </summary>
            <param name="self">
            The input <see cref="T:Supremes.Nodes.Element"/>,
            which acts as the <b>this</b> instance for the extension method.
            </param>
            <param name="html">HTML to parse and set into this element</param>
            <returns>The input <see cref="T:Supremes.Nodes.Element"/>, for method chaining.</returns>
            <seealso cref="P:Supremes.Nodes.Element.Html">Element.Html</seealso>
        </member>
        <member name="M:Supremes.Fluent.FluentUtility.Val(Supremes.Nodes.Elements,System.String)">
            <summary>
            Set the form element's value in each of the matched elements, and returns the elements itself.
            </summary>
            <param name="self">
            The input <see cref="T:Supremes.Nodes.Elements"/>,
            which acts as the <b>this</b> instance for the extension method.
            </param>
            <param name="value">the new value to set into each matched element</param>
            <returns>The input <see cref="T:Supremes.Nodes.Elements"/>, for method chaining.</returns>
            <seealso cref="P:Supremes.Nodes.Elements.Val">Elements.Val</seealso>
        </member>
        <member name="M:Supremes.Fluent.FluentUtility.TagName(Supremes.Nodes.Elements,System.String)">
            <summary>
            Set the tag name of each matched element, and returns the elements itself.
            </summary>
            <param name="self">
            The input <see cref="T:Supremes.Nodes.Elements"/>,
            which acts as the <b>this</b> instance for the extension method.
            </param>
            <param name="tagName">the new tag name to set into each matched element</param>
            <returns>The input <see cref="T:Supremes.Nodes.Elements"/>, for method chaining.</returns>
            <seealso cref="P:Supremes.Nodes.Elements.TagName">Elements.TagName</seealso>
        </member>
        <member name="M:Supremes.Fluent.FluentUtility.Html(Supremes.Nodes.Elements,System.String)">
            <summary>
            Set the inner HTML of each matched element, and returns the elements itself.
            </summary>
            <param name="self">
            The input <see cref="T:Supremes.Nodes.Elements"/>,
            which acts as the <b>this</b> instance for the extension method.
            </param>
            <param name="html">HTML to parse and set into each matched element</param>
            <returns>The input <see cref="T:Supremes.Nodes.Elements"/>, for method chaining.</returns>
            <seealso cref="P:Supremes.Nodes.Elements.Html">Elements.Html</seealso>
        </member>
        <member name="M:Supremes.Fluent.FluentUtility.Text(Supremes.Nodes.TextNode,System.String)">
            <summary>
            Set text content of the specified text node, and returns the text node itself.
            </summary>
            <param name="self">
            The input <see cref="T:Supremes.Nodes.TextNode"/>,
            which acts as the <b>this</b> instance for the extension method.
            </param>
            <param name="text">unencoded text</param>
            <returns>The input <see cref="T:Supremes.Nodes.TextNode"/>, for method chaining.</returns>
            <seealso cref="P:Supremes.Nodes.TextNode.Text">TextNode.Text</seealso>
        </member>
        <member name="T:Supremes.Helper.DescendableLinkedList`1">
            <summary>
            Provides a descending iterator and other 1.6 methods to allow support on the 1.5 JRE.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Supremes.Helper.DescendableLinkedList`1.#ctor">
            <summary>
            Create a new DescendableLinkedList.
            </summary>
        </member>
        <member name="M:Supremes.Helper.DescendableLinkedList`1.Push(`0)">
            <summary>
            Add a new element to the start of the list.
            </summary>
            <param name="e">element to add</param>
        </member>
        <member name="M:Supremes.Helper.DescendableLinkedList`1.PeekLast">
            <summary>
            Look at the last element, if there is one.
            </summary>
            <returns>the last element, or null</returns>
        </member>
        <member name="M:Supremes.Helper.DescendableLinkedList`1.PollLast">
            <summary>
            Remove and return the last element, if there is one
            </summary>
            <returns>the last element, or null</returns>
        </member>
        <member name="M:Supremes.Helper.DescendableLinkedList`1.GetDescendingEnumerator">
            <summary>
            Get an iterator that starts and the end of the list and works towards the start.
            </summary>
            <returns>
            an iterator that starts and the end of the list and works towards the start.
            </returns>
        </member>
        <member name="T:Supremes.Helper.Entities">
            <summary>
            HTML entities, and escape routines.
            </summary>
            <remarks>
            Source: <a href="http://www.w3.org/TR/html5/named-character-references.html#named-character-references">W3C HTML named character references</a>.
            </remarks>
        </member>
        <member name="M:Supremes.Helper.Entities.IsNamedEntity(System.String)">
            <summary>
            Check if the input is a known named entity
            </summary>
            <param name="name">the possible entity name (e.g. "lt" or "amp")</param>
            <returns>true if a known named entity</returns>
        </member>
        <member name="M:Supremes.Helper.Entities.IsBaseNamedEntity(System.String)">
            <summary>
            Check if the input is a known named entity in the base entity set.
            </summary>
            <param name="name">the possible entity name (e.g. "lt" or "amp")</param>
            <returns>true if a known named entity in the base set</returns>
            <seealso cref="M:Supremes.Helper.Entities.IsNamedEntity(System.String)">IsNamedEntity(string)</seealso>
        </member>
        <member name="M:Supremes.Helper.Entities.GetCharacterByName(System.String)">
            <summary>
            Get the Character value of the named entity
            </summary>
            <param name="name">named entity (e.g. "lt" or "amp")</param>
            <returns>the Character value of the named entity (e.g. '&lt;' or '&amp;')</returns>
        </member>
        <member name="M:Supremes.Helper.Entities.Unescape(System.String,System.Boolean)">
            <summary>
            Unescape the input string.
            </summary>
            <param name="string"></param>
            <param name="strict">if "strict" (that is, requires trailing ';' char, otherwise that's optional)
            </param>
            <returns></returns>
        </member>
        <member name="T:Supremes.Helper.StringUtil">
            <summary>
            A minimal String utility class.
            </summary>
            <remarks>
            Designed for internal jsoup use only.
            </remarks>
        </member>
        <member name="M:Supremes.Helper.StringUtil.Padding(System.Int32)">
            <summary>
            Returns space padding
            </summary>
            <param name="width">amount of padding desired</param>
            <returns>string of spaces * width</returns>
        </member>
        <member name="M:Supremes.Helper.StringUtil.IsNumeric(System.String)">
            <summary>
            Tests if a string is numeric
            </summary>
            <remarks>
            i.e. contains only digit characters
            </remarks>
            <param name="string">string to test</param>
            <returns>
            true if only digit chars, false if empty or null or contains non-digit chrs
            </returns>
        </member>
        <member name="M:Supremes.Helper.StringUtil.IsWhitespace(System.Char)">
            <summary>
            Tests if a code point is "whitespace" as defined in the HTML spec.
            </summary>
            <param name="c">UTF-16 character to test</param>
            <returns>true if UTF-16 character is whitespace, false otherwise</returns>
        </member>
        <member name="M:Supremes.Helper.StringUtil.NormaliseWhitespace(System.String)">
            <summary>
            Normalise the whitespace within this string
            </summary>
            <remarks>
            multiple spaces collapse to a single, and all whitespace characters
            (e.g. newline, tab) convert to a simple space
            </remarks>
            <param name="string">content to normalise</param>
            <returns>normalised string</returns>
        </member>
        <member name="M:Supremes.Helper.StringUtil.AppendNormalisedWhitespace(System.Text.StringBuilder,System.String,System.Boolean)">
            <summary>
            After normalizing the whitespace within a string, appends it to a string builder.
            </summary>
            <param name="accum">builder to append to</param>
            <param name="string">string to normalize whitespace within</param>
            <param name="stripLeading">
            set to true if you wish to remove any leading whitespace
            </param>
            <returns></returns>
        </member>
        <member name="T:Supremes.Helper.TokenQueue">
            <summary>
            A character queue with parsing helpers.
            </summary>
            <author>Jonathan Hedley</author>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.#ctor(System.String)">
            <summary>
            Create a new TokenQueue.
            </summary>
            <param name="data">string of data to back queue.</param>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.IsEmpty">
            <summary>
            Is the queue empty?
            </summary>
            <returns>true if no data left in queue.</returns>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.Peek">
            <summary>
            Retrieves but does not remove the first character from the queue.
            </summary>
            <returns>First character, or 0 if empty.</returns>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.AddFirst(System.Char)">
            <summary>
            Add a character to the start of the queue
            (will be the next character retrieved).
            </summary>
            <param name="c">character to add</param>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.AddFirst(System.String)">
            <summary>
            Add a string to the start of the queue.
            </summary>
            <param name="seq">string to add.</param>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.Matches(System.String)">
            <summary>
            Tests if the next characters on the queue match the sequence.
            </summary>
            <remarks>
            Case insensitive.
            </remarks>
            <param name="seq">String to check queue for.</param>
            <returns>true if the next characters match.</returns>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.MatchesCS(System.String)">
            <summary>
            Case sensitive match test.
            </summary>
            <param name="seq">string to case sensitively check for</param>
            <returns>true if matched, false if not</returns>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.MatchesAny(System.String[])">
            <summary>
            Tests if the next characters match any of the sequences.
            </summary>
            <remarks>
            Case insensitive.
            </remarks>
            <param name="seq">list of strings to case insensitively check for</param>
            <returns>true of any matched, false if none did</returns>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.MatchChomp(System.String)">
            <summary>
            Tests if the queue matches the sequence (as with match), 
            and if they do, removes the matched string from the queue.
            </summary>
            <param name="seq">String to search for, and if found, remove from queue.</param>
            <returns>true if found and removed, false if not found.</returns>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.MatchesWhitespace">
            <summary>
            Tests if queue starts with a whitespace character.
            </summary>
            <returns>if starts with whitespace</returns>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.MatchesWord">
            <summary>
            Test if the queue matches a word character (letter or digit).
            </summary>
            <returns>if matches a word character</returns>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.Advance">
            <summary>
            Drops the next character off the queue.
            </summary>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.Consume">
            <summary>
            Consume one character off queue.
            </summary>
            <returns>first character on queue.</returns>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.Consume(System.String)">
            <summary>
            Consumes the supplied sequence of the queue.
            </summary>
            <remarks>
            If the queue does not start with the supplied sequence, will
            throw an illegal state exception
            -- but you should be running match() against that condition.
            <p/>
            Case insensitive.
            </remarks>
            <param name="seq">sequence to remove from head of queue.</param>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.ConsumeTo(System.String)">
            <summary>
            Pulls a string off the queue, up to but exclusive of the match sequence,
            or to the queue running out.
            </summary>
            <param name="seq">
            String to end on (and not include in return, but leave on queue).
            <b>Case sensitive.</b>
            </param>
            <returns>The matched data consumed from queue.</returns>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.ConsumeToAny(System.String[])">
            <summary>
            Consumes to the first sequence provided, or to the end of the queue.
            </summary>
            <remarks>
            Leaves the terminator on the queue.
            </remarks>
            <param name="seq">
            any number of terminators to consume to.
            <b>Case insensitive.</b>
            </param>
            <returns>consumed string</returns>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.ChompTo(System.String)">
            <summary>
            Pulls a string off the queue (like consumeTo),
            and then pulls off the matched string (but does not return it).
            </summary>
            <remarks>
            If the queue runs out of characters before finding the seq,
            will return as much as it can
            (and queue will go isEmpty() == true).
            </remarks>
            <param name="seq">
            String to match up to, and not include in return, and to pull off queue.
            <b>Case sensitive.</b>
            </param>
            <returns>Data matched from queue.</returns>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.ChompBalanced(System.Char,System.Char)">
            <summary>
            Pulls a balanced string off the queue.
            </summary>
            <remarks>
            E.g. if queue is "(one (two) three) four", (,) will return "one (two) three",
            and leave " four" on the queue. Unbalanced openers and closers can be escaped (with \).
            Those escapes will be left in the returned string,
            which is suitable for regexes (where we need to preserve the escape),
            but unsuitable for contains text strings; use unescape for that.
            </remarks>
            <param name="open">opener</param>
            <param name="close">closer</param>
            <returns>data matched from the queue</returns>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.Unescape(System.String)">
            <summary>
            Unescaped a \ escaped string.
            </summary>
            <param name="in">backslash escaped string</param>
            <returns>unescaped string</returns>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.ConsumeWhitespace">
            <summary>
            Pulls the next run of whitespace characters of the queue.
            </summary>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.ConsumeWord">
            <summary>
            Retrieves the next run of word type (letter or digit) off the queue.
            </summary>
            <returns>String of word characters from queue, or empty string if none.</returns>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.ConsumeTagName">
            <summary>
            Consume an tag name off the queue (word or :, _, -)
            </summary>
            <returns>tag name</returns>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.ConsumeElementSelector">
            <summary>
            Consume a CSS element selector
            (tag name, but | instead of : for namespaces, to not conflict with :pseudo selects).
            </summary>
            <returns>tag name</returns>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.ConsumeCssIdentifier">
            <summary>
            Consume a CSS identifier (ID or class) off the queue (letter, digit, -, _)
            http://www.w3.org/TR/CSS2/syndata.html#value-def-identifier
            </summary>
            <returns>identifier</returns>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.ConsumeAttributeKey">
            <summary>
            Consume an attribute key off the queue (letter, digit, -, _, :")
            </summary>
            <returns>attribute key</returns>
        </member>
        <member name="M:Supremes.Helper.TokenQueue.Remainder">
            <summary>
            Consume and return whatever is left on the queue.
            </summary>
            <returns>remained of queue.</returns>
        </member>
        <member name="T:Supremes.Helper.Validate">
            <summary>
            Simple validation methods.
            </summary>
            <remarks>Designed for jsoup internal use</remarks>
        </member>
        <member name="M:Supremes.Helper.Validate.NotNull(System.Object)">
            <summary>
            Validates that the object is not null
            </summary>
            <param name="obj">object to test</param>
        </member>
        <member name="M:Supremes.Helper.Validate.NotNull(System.Object,System.String)">
            <summary>
            Validates that the object is not null
            </summary>
            <param name="obj">object to test</param>
            <param name="msg">message to output if validation fails</param>
        </member>
        <member name="M:Supremes.Helper.Validate.IsTrue(System.Boolean)">
            <summary>
            Validates that the value is true
            </summary>
            <param name="val">object to test</param>
        </member>
        <member name="M:Supremes.Helper.Validate.IsTrue(System.Boolean,System.String)">
            <summary>
            Validates that the value is true
            </summary>
            <param name="val">object to test</param>
            <param name="msg">message to output if validation fails</param>
        </member>
        <member name="M:Supremes.Helper.Validate.IsFalse(System.Boolean)">
            <summary>
            Validates that the value is false
            </summary>
            <param name="val">object to test</param>
        </member>
        <member name="M:Supremes.Helper.Validate.IsFalse(System.Boolean,System.String)">
            <summary>
            Validates that the value is false
            </summary>
            <param name="val">object to test</param>
            <param name="msg">message to output if validation fails</param>
        </member>
        <member name="M:Supremes.Helper.Validate.NoNullElements(System.Object[])">
            <summary>
            Validates that the array contains no null elements
            </summary>
            <param name="objects">the array to test</param>
        </member>
        <member name="M:Supremes.Helper.Validate.NoNullElements(System.Object[],System.String)">
            <summary>
            Validates that the array contains no null elements
            </summary>
            <param name="objects">the array to test</param>
            <param name="msg">message to output if validation fails</param>
        </member>
        <member name="M:Supremes.Helper.Validate.NotEmpty(System.String)">
            <summary>
            Validates that the string is not empty
            </summary>
            <param name="string">the string to test</param>
        </member>
        <member name="M:Supremes.Helper.Validate.NotEmpty(System.String,System.String)">
            <summary>
            Validates that the string is not empty
            </summary>
            <param name="string">the string to test</param>
            <param name="msg">message to output if validation fails</param>
        </member>
        <member name="M:Supremes.Helper.Validate.Fail(System.String)">
            <summary>
            Cause a failure.
            </summary>
            <param name="msg">message to output.</param>
        </member>
        <member name="T:Supremes.Nodes.Attribute">
            <summary>
            A single key + value attribute.
            </summary>
            <remarks>
            Keys are trimmed and normalised to lower-case.
            </remarks>
            <author>Jonathan Hedley, jonathan@hedley.net</author>
        </member>
        <member name="M:Supremes.Nodes.Attribute.#ctor(System.String,System.String)">
            <summary>
            Create a new attribute from unencoded (raw) key and value.
            </summary>
            <param name="key">attribute key</param>
            <param name="value">attribute value</param>
            <seealso cref="M:Supremes.Nodes.Attribute.CreateFromEncoded(System.String,System.String)">
            CreateFromEncoded(string, string)
            </seealso>
        </member>
        <member name="P:Supremes.Nodes.Attribute.Key">
            <summary>
            Get or set the attribute key.
            </summary>
            <returns>the attribute key</returns>
            <value>the new key; must not be null when set</value>
        </member>
        <member name="P:Supremes.Nodes.Attribute.Value">
            <summary>
            Get or set the attribute value.
            </summary>
            <returns>the attribute value</returns>
            <value>the new attribute value; must not be null when set</value>
        </member>
        <member name="P:Supremes.Nodes.Attribute.Html">
            <summary>
            Get the HTML representation of this attribute.
            </summary>
            <remarks>
            e.g. <c>href="index.html"</c>.
            </remarks>
            <returns>HTML</returns>
        </member>
        <member name="M:Supremes.Nodes.Attribute.ToString">
            <summary>
            Get the string representation of this attribute, implemented as
            <see cref="P:Supremes.Nodes.Attribute.Html">Html</see>
            .
            </summary>
            <returns>string</returns>
        </member>
        <member name="M:Supremes.Nodes.Attribute.CreateFromEncoded(System.String,System.String)">
            <summary>
            Create a new Attribute from an unencoded key and a HTML attribute encoded value.
            </summary>
            <param name="unencodedKey">
            assumes the key is not encoded, as can be only run of simple \w chars.
            </param>
            <param name="encodedValue">HTML attribute encoded value</param>
            <returns>attribute</returns>
        </member>
        <member name="M:Supremes.Nodes.Attribute.ShouldCollapseAttribute(Supremes.Nodes.DocumentOutputSettings)">
            <summary>
            Collapsible if it's a boolean attribute and value is empty or same as name
            </summary>
        </member>
        <member name="M:Supremes.Nodes.Attribute.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:Supremes.Nodes.Attribute"/> instances for equality.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Supremes.Nodes.Attribute.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Supremes.Nodes.Attributes">
            <summary>
            The attributes of an Element.
            </summary>
            <remarks>
            Attributes are treated as a map: there can be only one value associated with an attribute key.
            <p/>
            Attribute key and value comparisons are done case insensitively, and keys are normalised to
            lower-case.
            </remarks>
            <author>Jonathan Hedley, jonathan@hedley.net</author>
        </member>
        <member name="P:Supremes.Nodes.Attributes.Item(System.String)">
            <summary>
            Get an attribute value by key.
            Set a new attribute, or replace an existing one by key.
            </summary>
            <param name="key">the attribute key</param>
            <value>attribute value</value>
            <returns>the attribute value if set; or empty string if not set.</returns>
            <seealso cref="M:Supremes.Nodes.Attributes.ContainsKey(System.String)">ContainsKey(string)</seealso>
        </member>
        <member name="M:Supremes.Nodes.Attributes.Put(Supremes.Nodes.Attribute)">
            <summary>
            Set a new attribute, or replace an existing one by key.
            </summary>
            <param name="attribute">attribute</param>
        </member>
        <member name="M:Supremes.Nodes.Attributes.Remove(System.String)">
            <summary>
            Remove an attribute by key.
            </summary>
            <param name="key">attribute key to remove</param>
        </member>
        <member name="M:Supremes.Nodes.Attributes.ContainsKey(System.String)">
            <summary>
            Tests if these attributes contain an attribute with this key.
            </summary>
            <param name="key">key to check for</param>
            <returns>true if key exists, false otherwise</returns>
        </member>
        <member name="P:Supremes.Nodes.Attributes.Count">
            <summary>
            Get the number of attributes in this set.
            </summary>
            <returns>size</returns>
        </member>
        <member name="M:Supremes.Nodes.Attributes.SetAll(Supremes.Nodes.Attributes)">
            <summary>
            Add all the attributes from the incoming set to this set.
            </summary>
            <param name="incoming">attributes to add to these attributes.</param>
        </member>
        <member name="M:Supremes.Nodes.Attributes.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="T:Supremes.Nodes.Attributes"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Supremes.Nodes.Attributes.AsList">
            <summary>
            Get the attributes as a List, for iteration.
            </summary>
            <remarks>
            Get the attributes as a List, for iteration. Do not modify the keys of the attributes via this view, as changes
            to keys will not be recognised in the containing set.
            </remarks>
            <returns>an view of the attributes as a List.</returns>
        </member>
        <member name="P:Supremes.Nodes.Attributes.Dataset">
            <summary>
            Retrieves a filtered view of attributes that are HTML5 custom data attributes; that is, attributes with keys
            starting with
            <c>data-</c>
            .
            </summary>
            <returns>map of custom data attributes.</returns>
        </member>
        <member name="P:Supremes.Nodes.Attributes.Html">
            <summary>
            Get the HTML representation of these attributes.
            </summary>
            <returns>HTML</returns>
        </member>
        <member name="M:Supremes.Nodes.Attributes.ToString">
            <summary>
            Converts the value of this instance to a string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Supremes.Nodes.Attributes.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:Supremes.Nodes.Attributes"/> instances for equality.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Supremes.Nodes.Attributes.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Supremes.Nodes.Comment">
            <summary>
            A comment node.
            </summary>
            <author>Jonathan Hedley, jonathan@hedley.net</author>
        </member>
        <member name="M:Supremes.Nodes.Comment.#ctor(System.String,System.String)">
            <summary>
            Create a new comment node.
            </summary>
            <param name="data">The contents of the comment</param>
            <param name="baseUri">base URI</param>
        </member>
        <member name="P:Supremes.Nodes.Comment.Data">
            <summary>
            Get the contents of the comment.
            </summary>
            <returns>comment content</returns>
        </member>
        <member name="M:Supremes.Nodes.Comment.ToString">
            <summary>
            Converts the value of this instance to a string.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Supremes.Nodes.DataNode">
            <summary>
            A data node, for contents of style, script tags etc, where contents should not show in text().
            </summary>
            <author>Jonathan Hedley, jonathan@hedley.net</author>
        </member>
        <member name="M:Supremes.Nodes.DataNode.#ctor(System.String,System.String)">
            <summary>
            Create a new DataNode.
            </summary>
            <param name="data">data contents</param>
            <param name="baseUri">base URI</param>
        </member>
        <member name="P:Supremes.Nodes.DataNode.WholeData">
            <summary>
            Get or Set the data contents of this node.
            </summary>
            <remarks>
            if you want to use fluent API, write <c>using Supremes.Fluent;</c>.
            </remarks>
            <value>unencoded data</value>
            <returns>data will be unescaped and with original new lines, space etc.</returns>
            <seealso cref="T:Supremes.Fluent.FluentUtility">Supremes.Fluent.FluentUtility</seealso>
        </member>
        <member name="M:Supremes.Nodes.DataNode.ToString">
            <summary>
            Converts the value of this instance to a string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Supremes.Nodes.DataNode.CreateFromEncoded(System.String,System.String)">
            <summary>
            Create a new DataNode from HTML encoded data.
            </summary>
            <param name="encodedData">encoded data</param>
            <param name="baseUri">base URI</param>
            <returns>new DataNode</returns>
        </member>
        <member name="T:Supremes.Nodes.DocumentEscapeMode">
            <summary>
            Specifies the document's current HTML escape mode.
            </summary>
        </member>
        <member name="F:Supremes.Nodes.DocumentEscapeMode.Xhtml">
            <summary>
            Restricted entities suitable for XHTML output: lt, gt, amp, and quot only.
            </summary>
        </member>
        <member name="F:Supremes.Nodes.DocumentEscapeMode.Base">
            <summary>
            Default HTML output entities.
            </summary>
        </member>
        <member name="F:Supremes.Nodes.DocumentEscapeMode.Extended">
            <summary>
            Complete HTML entities.
            </summary>
        </member>
        <member name="T:Supremes.Nodes.DocumentSyntax">
            <summary>
            Specifies the output serialization syntax.
            </summary>
        </member>
        <member name="F:Supremes.Nodes.DocumentSyntax.Html">
            <summary>
            Serialize according to the HTML rules.
            </summary>
        </member>
        <member name="F:Supremes.Nodes.DocumentSyntax.Xml">
            <summary>
            Serialize according to the XML rules.
            </summary>
        </member>
        <member name="T:Supremes.Nodes.DocumentQuirksMode">
            <summary>
            Specifies how browsers should display an HTML file.
            </summary>
        </member>
        <member name="F:Supremes.Nodes.DocumentQuirksMode.NoQuirks">
            <summary>
            Follows Web standards.
            </summary>
        </member>
        <member name="F:Supremes.Nodes.DocumentQuirksMode.Quirks">
            <summary>
            Emulate non-standard behavior of older browsers.
            </summary>
        </member>
        <member name="F:Supremes.Nodes.DocumentQuirksMode.LimitedQuirks">
            <summary>
            Almost follows Web standards except few behaviors.
            </summary>
        </member>
        <member name="T:Supremes.Nodes.DocumentOutputSettings">
            <summary>
            A Document's output settings control the form of the text() and html() methods.
            </summary>
        </member>
        <member name="P:Supremes.Nodes.DocumentOutputSettings.EscapeMode">
            <summary>
            Get or Set the document's current HTML escape mode,
            which determines how characters are escaped
            when the output character set does not support a given character.
            </summary>
            <remarks>
            <para>
            <c>Base</c>, which provides a limited set of named HTML entities
            and escapes other characters as numbered entities for maximum compatibility;
            or <c>Extended</c>, which uses the complete set of HTML named entities.
            </para>
            <para>
            The default escape mode is <c>Base</c>.
            </para>
            <para>
            if you want to use fluent API, write <c>using Supremes.Fluent;</c>.
            </para>
            </remarks>
            <value>the new escape mode to use</value>
            <returns>the document's current escape mode</returns>
            <seealso cref="T:Supremes.Fluent.FluentUtility">Supremes.Fluent.FluentUtility</seealso>
        </member>
        <member name="P:Supremes.Nodes.DocumentOutputSettings.Charset">
            <summary>
            Get or Set the document's current output charset, 
            which is used to control which characters are escaped
            when generating HTML (via the <c>Html</c> properties),
            and which are kept intact.
            </summary>
            <remarks>
            <para>
            Where possible (when parsing from a URL or File),
            the document's output charset is automatically set to the input charset.
            Otherwise, it defaults to utf-8.
            </para>
            <para>
            if you want to use fluent API, write <c>using Supremes.Fluent;</c>.
            </para>
            </remarks>
            <value>the new charset to use</value>
            <returns>the document's current charset</returns>
            <seealso cref="T:Supremes.Fluent.FluentUtility">Supremes.Fluent.FluentUtility</seealso>
        </member>
        <member name="P:Supremes.Nodes.DocumentOutputSettings.Syntax">
            <summary>
            Get or Set the document's current output syntax.
            </summary>
            <remarks>
            <para>
            Either <c>Html</c>, with empty tags and boolean attributes (etc),
            or <c>Xml</c>, with self-closing tags.
            </para>
            <para>
            if you want to use fluent API, write <c>using Supremes.Fluent;</c>.
            </para>
            </remarks>
            <value>serialization syntax</value>
            <returns>current syntax</returns>
            <seealso cref="T:Supremes.Fluent.FluentUtility">Supremes.Fluent.FluentUtility</seealso>
        </member>
        <member name="P:Supremes.Nodes.DocumentOutputSettings.PrettyPrint">
            <summary>
            Get or Set if pretty printing is enabled.
            </summary>
            <remarks>
            <para>
            Default is true. If disabled, the HTML output methods will not re-format
            the output, and the output will generally look like the input.
            </para>
            <para>
            if you want to use fluent API, write <c>using Supremes.Fluent;</c>.
            </para>
            </remarks>
            <value>new pretty print setting</value>
            <returns>if pretty printing is enabled.</returns>
            <seealso cref="T:Supremes.Fluent.FluentUtility">Supremes.Fluent.FluentUtility</seealso>
        </member>
        <member name="P:Supremes.Nodes.DocumentOutputSettings.Outline">
            <summary>
            Get or Set if outline mode is enabled.
            </summary>
            <remarks>
            <para>
            Default is false.
            If enabled, the HTML output methods will consider all tags as block.
            </para>
            <para>
            if you want to use fluent API, write <c>using Supremes.Fluent;</c>.
            </para>
            </remarks>
            <value>new outline setting</value>
            <returns>true if outline mode is enabled</returns>
            <seealso cref="T:Supremes.Fluent.FluentUtility">Supremes.Fluent.FluentUtility</seealso>
        </member>
        <member name="P:Supremes.Nodes.DocumentOutputSettings.IndentAmount">
            <summary>
            Get or Set the current tag indent amount, used when pretty printing.
            </summary>
            <para>
            if you want to use fluent API, write <c>using Supremes.Fluent;</c>.
            </para>
            <value>number of spaces to use for indenting each level. Must be &gt;= 0</value>
            <returns>the current indent amount</returns>
            <seealso cref="T:Supremes.Fluent.FluentUtility">Supremes.Fluent.FluentUtility</seealso>
        </member>
        <member name="T:Supremes.Nodes.Document">
            <summary>
            A HTML Document.
            </summary>
            <author>Jonathan Hedley, jonathan@hedley.net</author>
        </member>
        <member name="M:Supremes.Nodes.Document.#ctor(System.String)">
            <summary>
            Create a new, empty Document.
            </summary>
            <param name="baseUri">base URI of document</param>
            <seealso cref="M:Supremes.Dcsoup.Parse(System.String)">Supremes.Dcsoup.Parse(string)</seealso>
            <seealso cref="M:Supremes.Nodes.Document.CreateShell(System.String)">CreateShell(string)</seealso>
        </member>
        <member name="M:Supremes.Nodes.Document.CreateShell(System.String)">
            <summary>
            Create a valid, empty shell of a document, suitable for adding more elements to.
            </summary>
            <param name="baseUri">baseUri of document</param>
            <returns>document with html, head, and body elements.</returns>
        </member>
        <member name="P:Supremes.Nodes.Document.Location">
            <summary>
            Get the URL this Document was parsed from.
            </summary>
            <remarks>
            If the starting URL is a redirect,
            this will return the final URL from which the document was served from.
            </remarks>
            <returns>location</returns>
        </member>
        <member name="P:Supremes.Nodes.Document.Head">
            <summary>
            Accessor to the document's
            <c>head</c>
            element.
            </summary>
            <returns>
            <c>head</c>
            </returns>
        </member>
        <member name="P:Supremes.Nodes.Document.Body">
            <summary>
            Accessor to the document's <c>body</c> element.
            </summary>
            <returns><c>body</c></returns>
        </member>
        <member name="P:Supremes.Nodes.Document.Title">
            <summary>
            Get or Set the string contents of the document's <c>title</c> element.
            </summary>
            <remarks>
            when set, updates the existing element,
            or adds <c>title</c> to <c>head</c> if not present
            </remarks>
            <value>string to set as title</value>
            <returns>Trimmed title, or empty string if none set.</returns>
        </member>
        <member name="M:Supremes.Nodes.Document.CreateElement(System.String)">
            <summary>
            Create a new Element, with this document's base uri.
            </summary>
            <remarks>
            Does not make the new element a child of this document.
            </remarks>
            <param name="tagName">
            element tag name (e.g.
            <c>a</c>
            )
            </param>
            <returns>new element</returns>
        </member>
        <member name="M:Supremes.Nodes.Document.Normalise">
            <summary>
            Normalise the document.
            </summary>
            <remarks>
            This happens after the parse phase so generally does not need to be called.
            Moves any text content that is not in the body element into the body.
            </remarks>
            <returns>this document after normalisation</returns>
        </member>
        <member name="P:Supremes.Nodes.Document.OuterHtml">
            <summary>
            Get the outer HTML of this document.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Supremes.Nodes.Document.Text">
            <summary>
            Get or Set the combined text of this element and all its children.
            </summary>
            <remarks>
            <para>
            when get, whitespace is normalized and trimmed.
            <p/>
            For example, given HTML
            <c>&lt;p&gt;Hello  &lt;b&gt;there&lt;/b&gt; now! &lt;/p&gt;</c>,
            <c>p.Text</c> returns <c>"Hello there now!"</c>
            </para>
            <para>
            when set, any existing contents (text or elements) will be cleared.
            </para>
            <para>
            if you want to use fluent API, write <c>using Supremes.Fluent;</c>.
            </para>
            </remarks>
            <value>unencoded text</value>
            <returns>unencoded text, or empty string if none.</returns>
            <seealso cref="T:Supremes.Fluent.FluentUtility">Supremes.Fluent.FluentUtility</seealso>
        </member>
        <member name="P:Supremes.Nodes.Document.OutputSettings">
            <summary>
            Get or Set the document's current output settings.
            </summary>
            <remarks>
            if you want to use fluent API, write <c>using Supremes.Fluent;</c>.
            </remarks>
            <value>new output settings</value>
            <returns>the document's current output settings</returns>
            <seealso cref="T:Supremes.Fluent.FluentUtility">Supremes.Fluent.FluentUtility</seealso>
        </member>
        <member name="P:Supremes.Nodes.Document.QuirksMode">
            <summary>
            Get or Set the document's quirks mode.
            </summary>
            <remarks>
            if you want to use fluent API, write <c>using Supremes.Fluent;</c>.
            </remarks>
            <seealso cref="T:Supremes.Fluent.FluentUtility">Supremes.Fluent.FluentUtility</seealso>
        </member>
        <member name="T:Supremes.Nodes.DocumentType">
            <summary>
            A
            <c>&lt;!DOCTYPE&gt;</c>
            node.
            </summary>
        </member>
        <member name="M:Supremes.Nodes.DocumentType.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Create a new doctype element.
            </summary>
            <param name="name">the doctype's name</param>
            <param name="publicId">the doctype's public ID</param>
            <param name="systemId">the doctype's system ID</param>
            <param name="baseUri">the doctype's base URI</param>
        </member>
        <member name="T:Supremes.Nodes.Element">
            <summary>
            A HTML element consists of a tag name, attributes, and child nodes
            (including text nodes and other elements).
            </summary>
            <remarks>
            From an Element, you can extract data, traverse the node graph, and manipulate the HTML.
            </remarks>
            <author>Jonathan Hedley, jonathan@hedley.net</author>
        </member>
        <member name="M:Supremes.Nodes.Element.#ctor(Supremes.Nodes.Tag,System.String,Supremes.Nodes.Attributes)">
            <summary>
            Create a new, standalone Element.
            </summary>
            <remarks>
            (Standalone in that is has no parent.)
            </remarks>
            <param name="tag">tag of this element</param>
            <param name="baseUri">the base URI</param>
            <param name="attributes">initial attributes</param>
            <seealso cref="M:Supremes.Nodes.Element.AppendChild(Supremes.Nodes.Node)">AppendChild(Node)</seealso>
            <seealso cref="M:Supremes.Nodes.Element.AppendElement(System.String)">AppendElement(string)</seealso>
        </member>
        <member name="M:Supremes.Nodes.Element.#ctor(Supremes.Nodes.Tag,System.String)">
            <summary>
            Create a new Element from a tag and a base URI.
            </summary>
            <param name="tag">element tag</param>
            <param name="baseUri">
            the base URI of this element. It is acceptable for the base URI to be an empty
            string, but not null.
            </param>
            <seealso cref="M:Supremes.Nodes.Tag.ValueOf(System.String)">Tag.ValueOf(string)</seealso>
        </member>
        <member name="P:Supremes.Nodes.Element.TagName">
            <summary>
            Get or Set the name of the tag for this element.
            </summary>
            <remarks>
            <para>
            E.g. <c>div</c>
            </para>
            <para>
            For example, convert a <c>&lt;span&gt;</c> to a <c>&lt;div&gt;</c>
            with <c>el.TagName = "div";</c> .
            </para>
            <para>
            if you want to use fluent API, write <c>using Supremes.Fluent;</c>.
            </para>
            </remarks>
            <value>the new tag name</value>
            <returns>the tag name</returns>
            <seealso cref="T:Supremes.Fluent.FluentUtility">Supremes.Fluent.FluentUtility</seealso>
        </member>
        <member name="P:Supremes.Nodes.Element.Tag">
            <summary>
            Get the Tag for this element.
            </summary>
            <returns>the tag object</returns>
        </member>
        <member name="P:Supremes.Nodes.Element.IsBlock">
            <summary>
            Test if this element is a block-level element.
            </summary>
            <remarks>
            (E.g.
            <c>&lt;div&gt; == true</c>
            or an inline element
            <c>&lt;p&gt; == false</c>
            ).
            </remarks>
            <returns>true if block, false if not (and thus inline)</returns>
        </member>
        <member name="P:Supremes.Nodes.Element.Id">
            <summary>
            Get the <c>id</c> attribute of this element.
            </summary>
            <returns>The id attribute, if present, or an empty string if not.</returns>
        </member>
        <member name="M:Supremes.Nodes.Element.Attr(System.String,System.String)">
            <summary>
            Set an attribute value on this element.
            </summary>
            <remarks>
            If this element already has an attribute with the
            key, its value is updated; otherwise, a new attribute is added.
            </remarks>
            <returns>this element</returns>
        </member>
        <member name="P:Supremes.Nodes.Element.Dataset">
            <summary>
            Get this element's HTML5 custom data attributes.
            </summary>
            <remarks>
            Each attribute in the element that has a key
            starting with "data-" is included the dataset.
            <p/>
            E.g., the element
            <c>&lt;div data-package="jsoup" data-language="Java" class="group"&gt;...</c>
            has the dataset
            <c>package=jsoup, language=java</c>
            .
            <p/>
            This map is a filtered view of the element's attribute map. Changes to one map (add, remove, update) are reflected
            in the other map.
            <p/>
            You can find elements that have data attributes using the
            <c>[^data-]</c>
            attribute key prefix selector.
            </remarks>
            <returns>
            a map of
            <c>key=value</c>
            custom data attributes.
            </returns>
        </member>
        <member name="P:Supremes.Nodes.Element.Parent">
            <summary>
            Gets this element's parent element.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Supremes.Nodes.Element.Parents">
            <summary>
            Get this element's parent and ancestors, up to the document root.
            </summary>
            <returns>this element's stack of parents, closest first.</returns>
        </member>
        <member name="M:Supremes.Nodes.Element.Child(System.Int32)">
            <summary>
            Get a child element of this element, by its 0-based index number.
            </summary>
            <remarks>
            Note that an element can have both mixed Nodes and Elements as children. This method inspects
            a filtered list of children that are elements, and the index is based on that filtered list.
            </remarks>
            <param name="index">the index number of the element to retrieve</param>
            <returns>
            the child element, if it exists, otherwise throws an
            <c>IndexOutOfBoundsException</c>
            </returns>
            <seealso cref="M:Supremes.Nodes.Node.ChildNode(System.Int32)">Node.ChildNode(int)</seealso>
        </member>
        <member name="P:Supremes.Nodes.Element.Children">
            <summary>
            Get this element's child elements.
            </summary>
            <remarks>
            This is effectively a filter on
            <see cref="P:Supremes.Nodes.Node.ChildNodes">Node.ChildNodes</see>
            to get Element nodes.
            </remarks>
            <returns>
            child elements. If this element has no children, returns an
            empty list.
            </returns>
            <seealso cref="P:Supremes.Nodes.Node.ChildNodes">Node.ChildNodes</seealso>
        </member>
        <member name="P:Supremes.Nodes.Element.TextNodes">
            <summary>
            Get this element's child text nodes.
            </summary>
            <remarks>
            The list is unmodifiable but the text nodes may be manipulated.
            <p/>
            This is effectively a filter on
            <see cref="P:Supremes.Nodes.Node.ChildNodes">Node.ChildNodes</see>
            to get Text nodes.
            </remarks>
            <returns>
            child text nodes. If this element has no text nodes, returns an
            empty list.
            <p/>
            For example, with the input HTML:
            <c><![CDATA[<p>One <span>Two</span> Three <br /> Four</p>]]></c>
            with the
            <c>p</c>
            element selected:
            <ul>
            <li>
            <c>p.Text</c>
            =
            <c>"One Two Three Four"</c>
            </li>
            <li>
            <c>p.OwnText</c>
            =
            <c>"One Three Four"</c>
            </li>
            <li>
            <c>p.Children</c>
            =
            <c>Elements[&lt;span&gt;, &lt;br /&gt;]</c>
            </li>
            <li>
            <c>p.ChildNodes</c>
            =
            <c>List&lt;Node&gt;["One ", &lt;span&gt;, " Three ", &lt;br /&gt;, " Four"]</c>
            </li>
            <li>
            <c>p.TextNodes</c>
            =
            <c>List&lt;TextNode&gt;["One ", " Three ", " Four"]</c>
            </li>
            </ul>
            </returns>
        </member>
        <member name="P:Supremes.Nodes.Element.DataNodes">
            <summary>
            Get this element's child data nodes.
            </summary>
            <remarks>
            <para>
            The list is unmodifiable but the data nodes may be manipulated.
            </para>
            <para>
            This is effectively a filter on
            <see cref="P:Supremes.Nodes.Node.ChildNodes">Node.ChildNodes</see>
            to get Data nodes.
            </para>
            </remarks>
            <returns>
            child data nodes. If this element has no data nodes, returns an
            empty list.
            </returns>
            <seealso cref="P:Supremes.Nodes.Element.Data">Data</seealso>
        </member>
        <member name="M:Supremes.Nodes.Element.Select(System.String)">
            <summary>
            Find elements that match the
            <see cref="T:Supremes.Select.Selector">Supremes.Select.Selector</see>
            CSS query, with this element as the starting context. Matched elements
            may include this element, or any of its children.
            </summary>
            <remarks>
            This method is generally more powerful to use than the DOM-type
            <c>GetElementBy*</c>
            methods, because
            multiple filters can be combined, e.g.:
            <ul>
            <li>
            <c>el.Select("a[href]")</c>
            - finds links (
            <c>a</c>
            tags with
            <c>href</c>
            attributes)
            </li>
            <li>
            <c>el.Select("a[href*=example.com]")</c>
            - finds links pointing to example.com (loosely)
            </li>
            </ul>
            <p/>
            See the query syntax documentation in
            <see cref="T:Supremes.Select.Selector">Supremes.Select.Selector</see>
            .
            </remarks>
            <param name="cssQuery">
            a
            <see cref="T:Supremes.Select.Selector">Supremes.Select.Selector</see>
            CSS-like query
            </param>
            <returns>elements that match the query (empty if none match)</returns>
            <seealso cref="T:Supremes.Select.Selector">Supremes.Select.Selector</seealso>
        </member>
        <member name="M:Supremes.Nodes.Element.AppendChild(Supremes.Nodes.Node)">
            <summary>
            Add a node child node to this element.
            </summary>
            <param name="child">node to add.</param>
            <returns>this element, so that you can add more child nodes or elements.</returns>
        </member>
        <member name="M:Supremes.Nodes.Element.PrependChild(Supremes.Nodes.Node)">
            <summary>
            Add a node to the start of this element's children.
            </summary>
            <param name="child">node to add.</param>
            <returns>this element, so that you can add more child nodes or elements.</returns>
        </member>
        <member name="M:Supremes.Nodes.Element.InsertChildren(System.Int32,System.Collections.Generic.IEnumerable{Supremes.Nodes.Node})">
            <summary>
            Inserts the given child nodes into this element at the specified index.
            </summary>
            <remarks>
            Current nodes will be shifted to the
            right. The inserted nodes will be moved from their current parent. To prevent moving, copy the nodes first.
            </remarks>
            <param name="index">
            0-based index to insert children at. Specify
            <c>0</c>
            to insert at the start,
            <c>-1</c>
            at the
            end
            </param>
            <param name="children">child nodes to insert</param>
            <returns>this element, for chaining.</returns>
        </member>
        <member name="M:Supremes.Nodes.Element.AppendElement(System.String)">
            <summary>
            Create a new element by tag name, and add it as the last child.
            </summary>
            <param name="tagName">
            the name of the tag (e.g.
            <c>div</c>
            ).
            </param>
            <returns>
            the new element, to allow you to add content to it, e.g.:
            <c>parent.AppendElement("h1").Attr("id", "header").Text("Welcome");</c>
            </returns>
        </member>
        <member name="M:Supremes.Nodes.Element.PrependElement(System.String)">
            <summary>
            Create a new element by tag name, and add it as the first child.
            </summary>
            <param name="tagName">
            the name of the tag (e.g.
            <c>div</c>
            ).
            </param>
            <returns>
            the new element, to allow you to add content to it, e.g.:
            <c>parent.PrependElement("h1").Attr("id", "header").Text("Welcome");</c>
            </returns>
        </member>
        <member name="M:Supremes.Nodes.Element.AppendText(System.String)">
            <summary>
            Create and append a new TextNode to this element.
            </summary>
            <param name="text">the unencoded text to add</param>
            <returns>this element</returns>
        </member>
        <member name="M:Supremes.Nodes.Element.PrependText(System.String)">
            <summary>
            Create and prepend a new TextNode to this element.
            </summary>
            <param name="text">the unencoded text to add</param>
            <returns>this element</returns>
        </member>
        <member name="M:Supremes.Nodes.Element.Append(System.String)">
            <summary>
            Add inner HTML to this element.
            </summary>
            <remarks>
            The supplied HTML will be parsed, and each node appended to the end of the children.
            </remarks>
            <param name="html">HTML to add inside this element, after the existing HTML</param>
            <returns>this element</returns>
            <seealso cref="P:Supremes.Nodes.Element.Html">Html</seealso>
        </member>
        <member name="M:Supremes.Nodes.Element.Prepend(System.String)">
            <summary>
            Add inner HTML into this element.
            </summary>
            <remarks>
            The supplied HTML will be parsed, and each node prepended to the start of the element's children.
            </remarks>
            <param name="html">HTML to add inside this element, before the existing HTML</param>
            <returns>this element</returns>
            <seealso cref="P:Supremes.Nodes.Element.Html">Html</seealso>
        </member>
        <member name="M:Supremes.Nodes.Element.Before(System.String)">
            <summary>
            Insert the specified HTML into the DOM before this element (as a preceding sibling).
            </summary>
            <param name="html">HTML to add before this element</param>
            <returns>this element, for chaining</returns>
            <seealso cref="M:Supremes.Nodes.Element.After(System.String)">After(string)</seealso>
        </member>
        <member name="M:Supremes.Nodes.Element.Before(Supremes.Nodes.Node)">
            <summary>
            Insert the specified node into the DOM before this node (as a preceding sibling).
            </summary>
            <param name="node">to add before this element</param>
            <returns>this Element, for chaining</returns>
            <seealso cref="M:Supremes.Nodes.Element.After(Supremes.Nodes.Node)">After(Node)</seealso>
        </member>
        <member name="M:Supremes.Nodes.Element.After(System.String)">
            <summary>
            Insert the specified HTML into the DOM after this element (as a following sibling).
            </summary>
            <param name="html">HTML to add after this element</param>
            <returns>this element, for chaining</returns>
            <seealso cref="M:Supremes.Nodes.Element.Before(System.String)">Before(string)</seealso>
        </member>
        <member name="M:Supremes.Nodes.Element.After(Supremes.Nodes.Node)">
            <summary>
            Insert the specified node into the DOM after this node (as a following sibling).
            </summary>
            <param name="node">to add after this element</param>
            <returns>this element, for chaining</returns>
            <seealso cref="M:Supremes.Nodes.Element.Before(Supremes.Nodes.Node)">Before(Node)</seealso>
        </member>
        <member name="M:Supremes.Nodes.Element.Empty">
            <summary>
            Remove all of the element's child nodes.
            </summary>
            <remarks>
            Any attributes are left as-is.
            </remarks>
            <returns>this element</returns>
        </member>
        <member name="M:Supremes.Nodes.Element.Wrap(System.String)">
            <summary>
            Wrap the supplied HTML around this element.
            </summary>
            <param name="html">
            HTML to wrap around this element, e.g.
            <c><![CDATA[<div class="head"></div>]]></c>
            . Can be arbitrarily deep.
            </param>
            <returns>this element, for chaining.</returns>
        </member>
        <member name="P:Supremes.Nodes.Element.CssSelector">
            <summary>
            Get a CSS selector that will uniquely select this element.
            </summary>
            <remarks>
            If the element has an ID, returns #id;
            otherwise returns the parent (if any) CSS selector, followed by '&gt;',
            followed by a unique selector for the element (tag.class.class:nth-child(n)).
            </remarks>
            <returns>the CSS Path that can be used to retrieve the element in a selector.</returns>
        </member>
        <member name="P:Supremes.Nodes.Element.SiblingElements">
            <summary>
            Get sibling elements.
            </summary>
            <remarks>
            If the element has no sibling elements, returns an empty list. An element is not a sibling
            of itself, so will not be included in the returned list.
            </remarks>
            <returns>sibling elements</returns>
        </member>
        <member name="P:Supremes.Nodes.Element.NextElementSibling">
            <summary>
            Gets the next sibling element of this element.
            </summary>
            <remarks>
            E.g., if a
            <c>div</c>
            contains two
            <c>p</c>
            s,
            the
            <c>NextElementSibling</c>
            of the first
            <c>p</c>
            is the second
            <c>p</c>
            .
            <p/>
            This is similar to
            <see cref="P:Supremes.Nodes.Node.NextSibling">Node.NextSibling</see>
            , but specifically finds only Elements
            </remarks>
            <returns>the next element, or null if there is no next element</returns>
            <seealso cref="P:Supremes.Nodes.Element.PreviousElementSibling">PreviousElementSibling</seealso>
        </member>
        <member name="P:Supremes.Nodes.Element.PreviousElementSibling">
            <summary>
            Gets the previous element sibling of this element.
            </summary>
            <returns>the previous element, or null if there is no previous element</returns>
            <seealso cref="P:Supremes.Nodes.Element.NextElementSibling">NextElementSibling</seealso>
        </member>
        <member name="P:Supremes.Nodes.Element.FirstElementSibling">
            <summary>
            Gets the first element sibling of this element.
            </summary>
            <returns>the first sibling that is an element (aka the parent's first element child)
            </returns>
        </member>
        <member name="P:Supremes.Nodes.Element.ElementSiblingIndex">
            <summary>
            Get the list index of this element in its element sibling list.
            </summary>
            <remarks>
            I.e. if this is the first element sibling, returns 0.
            </remarks>
            <returns>position in element sibling list</returns>
        </member>
        <member name="P:Supremes.Nodes.Element.LastElementSibling">
            <summary>
            Gets the last element sibling of this element
            </summary>
            <returns>
            the last sibling that is an element (aka the parent's last element child)
            </returns>
        </member>
        <member name="M:Supremes.Nodes.Element.GetElementsByTag(System.String)">
            <summary>
            Finds elements, including and recursively under this element,
            with the specified tag name.
            </summary>
            <param name="tagName">The tag name to search for (case insensitively).</param>
            <returns>
            a matching unmodifiable list of elements.
            Will be empty if this element and none of its children match.
            </returns>
        </member>
        <member name="M:Supremes.Nodes.Element.GetElementById(System.String)">
            <summary>
            Find an element by ID, including or under this element.
            </summary>
            <remarks>
            Note that this finds the first matching ID, starting with this element. If you search down from a different
            starting point, it is possible to find a different element by ID. For unique element by ID within a Document,
            use
            <see cref="M:Supremes.Nodes.Element.GetElementById(System.String)">Element.GetElementById(string)</see>
            </remarks>
            <param name="id">The ID to search for.</param>
            <returns>The first matching element by ID, starting with this element, or null if none found.
            </returns>
        </member>
        <member name="M:Supremes.Nodes.Element.GetElementsByClass(System.String)">
            <summary>
            Find elements that have this class, including or under this element.
            </summary>
            <remarks>
            Case insensitive.
            <p/>
            Elements can have multiple classes (e.g.
            <c>&lt;div class="header round first"&gt;</c>
            . This method
            checks each class, so you can find the above with
            <c>el.GetElementsByClass("header");</c>
            .
            </remarks>
            <param name="className">the name of the class to search for.</param>
            <returns>elements with the supplied class name, empty if none</returns>
            <seealso cref="M:Supremes.Nodes.Element.HasClass(System.String)">HasClass(string)</seealso>
            <seealso cref="P:Supremes.Nodes.Element.ClassNames">ClassNames</seealso>
        </member>
        <member name="M:Supremes.Nodes.Element.GetElementsByAttribute(System.String)">
            <summary>
            Find elements that have a named attribute set.
            </summary>
            <remarks>
            Case insensitive.
            </remarks>
            <param name="key">
            name of the attribute, e.g.
            <c>href</c>
            </param>
            <returns>elements that have this attribute, empty if none</returns>
        </member>
        <member name="M:Supremes.Nodes.Element.GetElementsByAttributeStarting(System.String)">
            <summary>
            Find elements that have an attribute name starting with the supplied prefix.
            </summary>
            <remarks>
            Use
            <c>data-</c>
            to find elements
            that have HTML5 datasets.
            </remarks>
            <param name="keyPrefix">
            name prefix of the attribute e.g.
            <c>data-</c>
            </param>
            <returns>elements that have attribute names that start with with the prefix, empty if none.
            </returns>
        </member>
        <member name="M:Supremes.Nodes.Element.GetElementsByAttributeValue(System.String,System.String)">
            <summary>
            Find elements that have an attribute with the specific value.
            </summary>
            <remarks>
            Case insensitive.
            </remarks>
            <param name="key">name of the attribute</param>
            <param name="value">value of the attribute</param>
            <returns>elements that have this attribute with this value, empty if none</returns>
        </member>
        <member name="M:Supremes.Nodes.Element.GetElementsByAttributeValueNot(System.String,System.String)">
            <summary>
            Find elements that either do not have this attribute,
            or have it with a different value.
            </summary>
            <remarks>
            Case insensitive.
            </remarks>
            <param name="key">name of the attribute</param>
            <param name="value">value of the attribute</param>
            <returns>elements that do not have a matching attribute</returns>
        </member>
        <member name="M:Supremes.Nodes.Element.GetElementsByAttributeValueStarting(System.String,System.String)">
            <summary>
            Find elements that have attributes that start with the value prefix.
            </summary>
            <remarks>
            Case insensitive.
            </remarks>
            <param name="key">name of the attribute</param>
            <param name="valuePrefix">start of attribute value</param>
            <returns>elements that have attributes that start with the value prefix</returns>
        </member>
        <member name="M:Supremes.Nodes.Element.GetElementsByAttributeValueEnding(System.String,System.String)">
            <summary>
            Find elements that have attributes that end with the value suffix.
            </summary>
            <remarks>
            Case insensitive.
            </remarks>
            <param name="key">name of the attribute</param>
            <param name="valueSuffix">end of the attribute value</param>
            <returns>elements that have attributes that end with the value suffix</returns>
        </member>
        <member name="M:Supremes.Nodes.Element.GetElementsByAttributeValueContaining(System.String,System.String)">
            <summary>
            Find elements that have attributes whose value contains the match string.
            </summary>
            <remarks>
            Case insensitive.
            </remarks>
            <param name="key">name of the attribute</param>
            <param name="match">substring of value to search for</param>
            <returns>elements that have attributes containing this text</returns>
        </member>
        <member name="M:Supremes.Nodes.Element.GetElementsByAttributeValueMatching(System.String,System.Text.RegularExpressions.Regex)">
            <summary>
            Find elements that have attributes whose values match the supplied regular expression.
            </summary>
            <param name="key">name of the attribute</param>
            <param name="pattern">compiled regular expression to match against attribute values
            </param>
            <returns>elements that have attributes matching this regular expression</returns>
        </member>
        <member name="M:Supremes.Nodes.Element.GetElementsByAttributeValueMatching(System.String,System.String)">
            <summary>
            Find elements that have attributes whose values match the supplied regular expression.
            </summary>
            <param name="key">name of the attribute</param>
            <param name="regex">regular expression to match against attribute values. You can use <a href="http://java.sun.com/docs/books/tutorial/essential/regex/pattern.html#embedded">embedded flags</a> (such as (?i) and (?m) to control regex options.
            </param>
            <returns>elements that have attributes matching this regular expression</returns>
        </member>
        <member name="M:Supremes.Nodes.Element.GetElementsByIndexLessThan(System.Int32)">
            <summary>
            Find elements whose sibling index is less than the supplied index.
            </summary>
            <param name="index">0-based index</param>
            <returns>elements less than index</returns>
        </member>
        <member name="M:Supremes.Nodes.Element.GetElementsByIndexGreaterThan(System.Int32)">
            <summary>
            Find elements whose sibling index is greater than the supplied index.
            </summary>
            <param name="index">0-based index</param>
            <returns>elements greater than index</returns>
        </member>
        <member name="M:Supremes.Nodes.Element.GetElementsByIndexEquals(System.Int32)">
            <summary>
            Find elements whose sibling index is equal to the supplied index.
            </summary>
            <param name="index">0-based index</param>
            <returns>elements equal to index</returns>
        </member>
        <member name="M:Supremes.Nodes.Element.GetElementsContainingText(System.String)">
            <summary>
            Find elements that contain the specified string.
            </summary>
            <remarks>
            The search is case insensitive. The text may appear directly
            in the element, or in any of its descendants.
            </remarks>
            <param name="searchText">to look for in the element's text</param>
            <returns>elements that contain the string, case insensitive.</returns>
            <seealso cref="P:Supremes.Nodes.Element.Text">Element.Text</seealso>
        </member>
        <member name="M:Supremes.Nodes.Element.GetElementsContainingOwnText(System.String)">
            <summary>
            Find elements that directly contain the specified string.
            </summary>
            <remarks>
            The search is case insensitive. The text must appear directly
            in the element, not in any of its descendants.
            </remarks>
            <param name="searchText">to look for in the element's own text</param>
            <returns>elements that contain the string, case insensitive.</returns>
            <seealso cref="P:Supremes.Nodes.Element.OwnText">Element.OwnText</seealso>
        </member>
        <member name="M:Supremes.Nodes.Element.GetElementsMatchingText(System.Text.RegularExpressions.Regex)">
            <summary>
            Find elements whose text matches the supplied regular expression.
            </summary>
            <param name="pattern">regular expression to match text against</param>
            <returns>elements matching the supplied regular expression.</returns>
            <seealso cref="P:Supremes.Nodes.Element.Text">Element.Text</seealso>
        </member>
        <member name="M:Supremes.Nodes.Element.GetElementsMatchingText(System.String)">
            <summary>
            Find elements whose text matches the supplied regular expression.
            </summary>
            <param name="regex">regular expression to match text against. You can use <a href="http://java.sun.com/docs/books/tutorial/essential/regex/pattern.html#embedded">embedded flags</a> (such as (?i) and (?m) to control regex options.
            </param>
            <returns>elements matching the supplied regular expression.</returns>
            <seealso cref="P:Supremes.Nodes.Element.Text">Element.Text</seealso>
        </member>
        <member name="M:Supremes.Nodes.Element.GetElementsMatchingOwnText(System.Text.RegularExpressions.Regex)">
            <summary>
            Find elements whose own text matches the supplied regular expression.
            </summary>
            <param name="pattern">regular expression to match text against</param>
            <returns>elements matching the supplied regular expression.</returns>
            <seealso cref="P:Supremes.Nodes.Element.OwnText">Element.OwnText</seealso>
        </member>
        <member name="M:Supremes.Nodes.Element.GetElementsMatchingOwnText(System.String)">
            <summary>
            Find elements whose text matches the supplied regular expression.
            </summary>
            <param name="regex">regular expression to match text against. You can use <a href="http://java.sun.com/docs/books/tutorial/essential/regex/pattern.html#embedded">embedded flags</a> (such as (?i) and (?m) to control regex options.
            </param>
            <returns>elements matching the supplied regular expression.</returns>
            <seealso cref="P:Supremes.Nodes.Element.OwnText">Element.OwnText</seealso>
        </member>
        <member name="M:Supremes.Nodes.Element.GetAllElements">
            <summary>
            Find all elements under this element (including self, and children of children).
            </summary>
            <returns>all elements</returns>
        </member>
        <member name="P:Supremes.Nodes.Element.Text">
            <summary>
            Get or Set the combined text of this element and all its children.
            </summary>
            <remarks>
            <para>
            when get, whitespace is normalized and trimmed.
            <p/>
            For example, given HTML
            <c>&lt;p&gt;Hello  &lt;b&gt;there&lt;/b&gt; now! &lt;/p&gt;</c>,
            <c>p.Text</c> returns <c>"Hello there now!"</c>
            </para>
            <para>
            when set, any existing contents (text or elements) will be cleared.
            </para>
            </remarks>
            <value>unencoded text</value>
            <returns>unencoded text, or empty string if none.</returns>
            <seealso cref="P:Supremes.Nodes.Element.OwnText">OwnText</seealso>
            <seealso cref="P:Supremes.Nodes.Element.TextNodes">TextNodes</seealso>
        </member>
        <member name="P:Supremes.Nodes.Element.OwnText">
            <summary>
            Gets the text owned by this element only;
            does not get the combined text of all children.
            </summary>
            <remarks>
            For example, given HTML
            <c>&lt;p&gt;Hello &lt;b&gt;there&lt;/b&gt; now!&lt;/p&gt;</c>
            ,
            <c>p.OwnText</c>
            returns
            <c>"Hello now!"</c>
            ,
            whereas
            <c>p.Text</c>
            returns
            <c>"Hello there now!"</c>
            .
            Note that the text within the
            <c>b</c>
            element is not returned, as it is not a direct child of the
            <c>p</c>
            element.
            </remarks>
            <returns>unencoded text, or empty string if none.</returns>
            <seealso cref="P:Supremes.Nodes.Element.Text">Text</seealso>
            <seealso cref="P:Supremes.Nodes.Element.TextNodes">TextNodes</seealso>
        </member>
        <member name="P:Supremes.Nodes.Element.HasText">
            <summary>
            Test if this element has any text content (that is not just whitespace).
            </summary>
            <returns>true if element has non-blank text content.</returns>
        </member>
        <member name="P:Supremes.Nodes.Element.Data">
            <summary>
            Get the combined data of this element.
            </summary>
            <remarks>
            Data is e.g. the inside of a
            <c>script</c>
            tag.
            </remarks>
            <returns>the data, or empty string if none</returns>
            <seealso cref="P:Supremes.Nodes.Element.DataNodes">DataNodes</seealso>
        </member>
        <member name="P:Supremes.Nodes.Element.ClassName">
            <summary>
            Gets the literal value of this element's "class" attribute,
            which may include multiple class names, space separated.
            </summary>
            <remarks>
            (E.g. on <c>&lt;div class="header gray"&gt;</c> returns,
            "<c>header gray</c>")
            </remarks>
            <returns>
            The literal class attribute, or <b>empty string</b>
            if no class attribute set.
            </returns>
        </member>
        <member name="P:Supremes.Nodes.Element.ClassNames">
            <summary>
            Get or Set all of the element's class names.
            </summary>
            <remarks>
            <para>
            E.g. on element
            <c>&lt;div class="header gray"&gt;</c>, 
            this property returns a set of two elements
            <c>"header", "gray"</c>.
            Note that modifications to this set are not pushed to
            the backing <c>class</c> attribute;
            use the
            <see cref="P:Supremes.Nodes.Element.ClassNames">ClassNames</see>
            method to persist them.
            </para>
            <para>
            if you want to use fluent API, write <c>using Supremes.Fluent;</c>.
            </para>
            </remarks>
            <value>the new set of classes</value>
            <returns>set of classnames, empty if no class attribute</returns>
            <seealso cref="T:Supremes.Fluent.FluentUtility">Supremes.Fluent.FluentUtility</seealso>
        </member>
        <member name="M:Supremes.Nodes.Element.HasClass(System.String)">
            <summary>
            Tests if this element has a class.
            </summary>
            <remarks>
            Case insensitive.
            </remarks>
            <param name="className">name of class to check for</param>
            <returns>true if it does, false if not</returns>
        </member>
        <member name="M:Supremes.Nodes.Element.AddClass(System.String)">
            <summary>
            Add a class name to this element's
            <c>class</c>
            attribute.
            </summary>
            <param name="className">class name to add</param>
            <returns>this element</returns>
        </member>
        <member name="M:Supremes.Nodes.Element.RemoveClass(System.String)">
            <summary>
            Remove a class name from this element's
            <c>class</c>
            attribute.
            </summary>
            <param name="className">class name to remove</param>
            <returns>this element</returns>
        </member>
        <member name="M:Supremes.Nodes.Element.ToggleClass(System.String)">
            <summary>
            Toggle a class name on this element's
            <c>class</c>
            attribute: if present, remove it; otherwise add it.
            </summary>
            <param name="className">class name to toggle</param>
            <returns>this element</returns>
        </member>
        <member name="P:Supremes.Nodes.Element.Val">
            <summary>
            Get or Set the value of a form element (input, textarea, etc).
            </summary>
            <remarks>
            <para>
            if you want to use fluent API, write <c>using Supremes.Fluent;</c>.
            </para>
            </remarks>
            <value>value to set</value>
            <returns>the value of the form element, or empty string if not set.</returns>
            <seealso cref="T:Supremes.Fluent.FluentUtility">Supremes.Fluent.FluentUtility</seealso>
        </member>
        <member name="P:Supremes.Nodes.Element.Html">
            <summary>
            Get Or Set the element's inner HTML.
            </summary>
            <remarks>
            <para>
            when get on a <c>&lt;div&gt;</c> with one empty <c>&lt;p&gt;</c>,
            would return <c>&lt;p&gt;&lt;/p&gt;</c>.
            (Whereas
            <see cref="P:Supremes.Nodes.Node.OuterHtml">Node.OuterHtml</see>
            would return
            <c>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;</c>.)
            </para>
            <para>
            when set, clears the existing HTML first.
            </para>
            <para>
            if you want to use fluent API, write <c>using Supremes.Fluent;</c>.
            </para>
            </remarks>
            <value>HTML to parse and set into this element</value>
            <returns>String of HTML.</returns>
            <seealso cref="P:Supremes.Nodes.Node.OuterHtml">Node.OuterHtml</seealso>
            <seealso cref="M:Supremes.Nodes.Element.Append(System.String)">Append(string)</seealso>
            <seealso cref="T:Supremes.Fluent.FluentUtility">Supremes.Fluent.FluentUtility</seealso>
        </member>
        <member name="M:Supremes.Nodes.Element.ToString">
            <summary>
            Converts the value of this instance to a string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Supremes.Nodes.Element.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:Supremes.Nodes.Element"/> instances for equality.
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Supremes.Nodes.Element.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Supremes.Nodes.Elements">
            <summary>
            A list of
            <see cref="T:Supremes.Nodes.Element">Element</see>
            s, with methods that act on every element in the list.
            <p/>
            To get an
            <c>Elements</c>
            object, use the
            <see cref="M:Supremes.Nodes.Element.Select(System.String)">Element.Select(string)</see>
            method.
            </summary>
            <author>Jonathan Hedley, jonathan@hedley.net</author>
        </member>
        <member name="M:Supremes.Nodes.Elements.Clone">
            <summary>
            Creates a deep copy of these elements.
            </summary>
            <returns>a deep copy</returns>
        </member>
        <member name="M:Supremes.Nodes.Elements.Attr(System.String)">
            <summary>
            Get an attribute value from the first matched element that has the attribute.
            </summary>
            <param name="attributeKey">The attribute key.</param>
            <returns>
            The attribute value from the first matched element that has the attribute.
            If no elements were matched (isEmpty() == true),
            or if the no elements have the attribute, returns empty string.
            </returns>
            <seealso cref="M:Supremes.Nodes.Elements.HasAttr(System.String)">HasAttr(string)</seealso>
        </member>
        <member name="M:Supremes.Nodes.Elements.HasAttr(System.String)">
            <summary>
            Checks if any of the matched elements have this attribute set.
            </summary>
            <param name="attributeKey">attribute key</param>
            <returns>true if any of the elements have the attribute; false if none do.</returns>
        </member>
        <member name="M:Supremes.Nodes.Elements.Attr(System.String,System.String)">
            <summary>
            Set an attribute on all matched elements.
            </summary>
            <param name="attributeKey">attribute key</param>
            <param name="attributeValue">attribute value</param>
            <returns>this</returns>
        </member>
        <member name="M:Supremes.Nodes.Elements.RemoveAttr(System.String)">
            <summary>
            Remove an attribute from every matched element.
            </summary>
            <param name="attributeKey">The attribute to remove.</param>
            <returns>this (for chaining)</returns>
        </member>
        <member name="M:Supremes.Nodes.Elements.AddClass(System.String)">
            <summary>
            Add the class name to every matched element's
            <c>class</c>
            attribute.
            </summary>
            <param name="className">class name to add</param>
            <returns>this</returns>
        </member>
        <member name="M:Supremes.Nodes.Elements.RemoveClass(System.String)">
            <summary>
            Remove the class name from every matched element's
            <c>class</c>
            attribute, if present.
            </summary>
            <param name="className">class name to remove</param>
            <returns>this</returns>
        </member>
        <member name="M:Supremes.Nodes.Elements.ToggleClass(System.String)">
            <summary>
            Toggle the class name on every matched element's
            <c>class</c>
            attribute.
            </summary>
            <param name="className">class name to add if missing, or remove if present, from every element.
            </param>
            <returns>this</returns>
        </member>
        <member name="M:Supremes.Nodes.Elements.HasClass(System.String)">
            <summary>
            Determine if any of the matched elements have this class name set in their
            <c>class</c>
            attribute.
            </summary>
            <param name="className">class name to check for</param>
            <returns>true if any do, false if none do</returns>
        </member>
        <member name="P:Supremes.Nodes.Elements.Val">
            <summary>
            Get the form element's value of the first matched element.
            Set the form element's value in each of the matched elements.
            </summary>
            <remarks>
            <para>
            if you want to use fluent API, write <c>using Supremes.Fluent;</c>.
            </para>
            </remarks>
            <value>The value to set into each matched element</value>
            <returns>The form element's value, or empty if not set.</returns>
            <seealso cref="P:Supremes.Nodes.Element.Val">Element.Val</seealso>
            <seealso cref="T:Supremes.Fluent.FluentUtility">Supremes.Fluent.FluentUtility</seealso>
        </member>
        <member name="P:Supremes.Nodes.Elements.Text">
            <summary>
            Get the combined text of all the matched elements.
            </summary>
            <remarks>
            Note that it is possible to get repeats if the matched elements contain both parent elements and their own
            children, as the Element.text() method returns the combined text of a parent and all its children.
            </remarks>
            <returns>string of all text: unescaped and no HTML.</returns>
            <seealso cref="P:Supremes.Nodes.Element.Text">Element.Text</seealso>
        </member>
        <member name="P:Supremes.Nodes.Elements.HasText">
            <summary>
            Determine if any of the matched elements have a text content (that is not just whitespace).
            </summary>
            <returns></returns>
        </member>
        <member name="P:Supremes.Nodes.Elements.Html">
            <summary>
            Get the combined inner HTML of all matched elements.
            Set the inner HTML of each matched element.
            </summary>
            <remarks>
            <para>
            if you want to use fluent API, write <c>using Supremes.Fluent;</c>.
            </para>
            </remarks>
            <value>HTML to parse and set into each matched element.</value>
            <returns>string of all element's inner HTML.</returns>
            <seealso cref="P:Supremes.Nodes.Elements.Text">Text</seealso>
            <seealso cref="P:Supremes.Nodes.Elements.OuterHtml">OuterHtml</seealso>
            <seealso cref="P:Supremes.Nodes.Element.Html">Element.Html</seealso>
            <seealso cref="T:Supremes.Fluent.FluentUtility">Supremes.Fluent.FluentUtility</seealso>
        </member>
        <member name="P:Supremes.Nodes.Elements.OuterHtml">
            <summary>
            Get the combined outer HTML of all matched elements.
            </summary>
            <returns>string of all element's outer HTML.</returns>
            <seealso cref="P:Supremes.Nodes.Elements.Text">Text</seealso>
            <seealso cref="P:Supremes.Nodes.Elements.Html">Html</seealso>
        </member>
        <member name="M:Supremes.Nodes.Elements.ToString">
            <summary>
            Get the combined outer HTML of all matched elements.
            </summary>
            <remarks>
            Alias of
            <see cref="P:Supremes.Nodes.Elements.OuterHtml">OuterHtml</see>
            .
            </remarks>
            <returns>string of all element's outer HTML.</returns>
            <seealso cref="P:Supremes.Nodes.Elements.Text">Text</seealso>
            <seealso cref="P:Supremes.Nodes.Elements.Html">Html</seealso>
        </member>
        <member name="P:Supremes.Nodes.Elements.TagName">
            <summary>
            Get the tag name of the first matched element.
            Set the tag name of each matched element.
            </summary>
            <remarks>
            <para>
            For example, to change each
            <c>&lt;i&gt;</c>
            to a
            <c>&lt;em&gt;</c>
            , do
            <c>doc.Select("i").TagName = "em";</c>
            </para>
            <para>
            if you want to use fluent API, write <c>using Supremes.Fluent;</c>.
            </para>
            </remarks>
            <value>the new tag name</value>
            <returns>The tag name of the first matched element, or empty if not matched.</returns>
            <seealso cref="P:Supremes.Nodes.Element.TagName">Element.TagName</seealso>
            <seealso cref="T:Supremes.Fluent.FluentUtility">Supremes.Fluent.FluentUtility</seealso>
        </member>
        <member name="M:Supremes.Nodes.Elements.Prepend(System.String)">
            <summary>
            Add the supplied HTML to the start of each matched element's inner HTML.
            </summary>
            <param name="html">HTML to add inside each element, before the existing HTML</param>
            <returns>this, for chaining</returns>
            <seealso cref="M:Supremes.Nodes.Element.Prepend(System.String)">Element.Prepend(string)</seealso>
        </member>
        <member name="M:Supremes.Nodes.Elements.Append(System.String)">
            <summary>
            Add the supplied HTML to the end of each matched element's inner HTML.
            </summary>
            <param name="html">HTML to add inside each element, after the existing HTML</param>
            <returns>this, for chaining</returns>
            <seealso cref="M:Supremes.Nodes.Element.Append(System.String)">Element.Append(string)</seealso>
        </member>
        <member name="M:Supremes.Nodes.Elements.Before(System.String)">
            <summary>
            Insert the supplied HTML before each matched element's outer HTML.
            </summary>
            <param name="html">HTML to insert before each element</param>
            <returns>this, for chaining</returns>
            <seealso cref="M:Supremes.Nodes.Node.Before(System.String)">Node.Before(string)</seealso>
        </member>
        <member name="M:Supremes.Nodes.Elements.After(System.String)">
            <summary>
            Insert the supplied HTML after each matched element's outer HTML.
            </summary>
            <param name="html">HTML to insert after each element</param>
            <returns>this, for chaining</returns>
            <seealso cref="M:Supremes.Nodes.Node.After(System.String)">Node.After(string)</seealso>
        </member>
        <member name="M:Supremes.Nodes.Elements.Wrap(System.String)">
            <summary>
            Wrap the supplied HTML around each matched elements.
            </summary>
            <remarks>
            For example, with HTML
            <c><![CDATA[<p><b>This</b> is <b>Nsoup</b></p>]]></c>
            ,
            <c>doc.Select("b").Wrap("&lt;i&gt;&lt;/i&gt;");</c>
            becomes
            <c><![CDATA[<p><i><b>This</b></i> is <i><b>jsoup</b></i></p>]]></c>
            </remarks>
            <param name="html">
            HTML to wrap around each element, e.g.
            <c><![CDATA[<div class="head"></div>]]></c>
            . Can be arbitrarily deep.
            </param>
            <returns>this (for chaining)</returns>
            <seealso cref="M:Supremes.Nodes.Element.Wrap(System.String)">Element.Wrap(string)</seealso>
        </member>
        <member name="M:Supremes.Nodes.Elements.Unwrap">
            <summary>
            Removes the matched elements from the DOM, and moves their children up into their parents.
            </summary>
            <remarks>
            <para>
            This has the effect of dropping the elements but keeping their children.
            </para>
            <para>
            This is useful for e.g removing unwanted formatting elements but keeping their contents.
            </para>
            <para>
            E.g. with HTML:
            <c>&lt;div&gt;&lt;font&gt;One&lt;/font&gt; &lt;font&gt;&lt;a href="/"&gt;Two&lt;/a&gt;&lt;/font&gt;&lt;/div&gt;</c>
            <br/>
            <c>doc.Select("font").Unwrap();</c>
            <br/>
            HTML =
            <c>&lt;div&gt;One &lt;a href="/"&gt;Two&lt;/a&gt;&lt;/div&gt;</c>
            </para>
            </remarks>
            <returns>this (for chaining)</returns>
            <seealso cref="M:Supremes.Nodes.Node.Unwrap">Node.Unwrap()</seealso>
        </member>
        <member name="M:Supremes.Nodes.Elements.Empty">
            <summary>
            Empty (remove all child nodes from) each matched element.
            </summary>
            <remarks>
            <para>
            This is similar to setting the inner HTML of each element to nothing.
            </para>
            <para>
            E.g. HTML:
            <c><![CDATA[<div><p>Hello <b>there</b></p> <p>now</p></div>]]></c>
            <br />
            <c>doc.Select("p").Empty();</c><br />
            HTML =
            <c><![CDATA[<div><p></p> <p></p></div>]]></c>
            </para>
            </remarks>
            <returns>this, for chaining</returns>
            <seealso cref="M:Supremes.Nodes.Element.Empty">Element.Empty()</seealso>
            <seealso cref="M:Supremes.Nodes.Elements.Remove">Remove()</seealso>
        </member>
        <member name="M:Supremes.Nodes.Elements.Remove">
            <summary>
            Remove each matched element from the DOM.
            </summary>
            <remarks>
            <para>
            This is similar to setting the outer HTML of each element to nothing.
            </para>
            <para>
            E.g. HTML:
            <c><![CDATA[<div><p>Hello</p> <p>there</p> <img /></div>]]></c>
            <br />
            <c>doc.Select("p").Remove();</c><br />
            HTML =
            <c><![CDATA[<div> <img /></div>]]></c>
            </para>
            <para>
            Note that this method should not be used to clean user-submitted HTML; rather, use
            <see cref="T:Supremes.Safety.Cleaner">Supremes.Safety.Cleaner</see>
            to clean HTML.
            </para>
            </remarks>
            <returns>this, for chaining</returns>
            <seealso cref="M:Supremes.Nodes.Element.Empty">Element.Empty()</seealso>
            <seealso cref="M:Supremes.Nodes.Elements.Empty">Empty()</seealso>
        </member>
        <member name="M:Supremes.Nodes.Elements.Select(System.String)">
            <summary>
            Find matching elements within this element list.
            </summary>
            <param name="query">
            A
            <see cref="T:Supremes.Select.Selector">Supremes.Select.Selector</see>
            query
            </param>
            <returns>the filtered list of elements, or an empty list if none match.</returns>
        </member>
        <member name="M:Supremes.Nodes.Elements.Not(System.String)">
            <summary>
            Remove elements from this list that match the
            <see cref="T:Supremes.Select.Selector">Supremes.Select.Selector</see>
            query.
            </summary>
            <remarks>
            <para>
            E.g. HTML:
            <c>&lt;div class=logo&gt;One&lt;/div&gt; &lt;div&gt;Two&lt;/div&gt;</c>
            <br />
            <c>Elements divs = doc.select("div").not("#logo");</c><br />
            Result:
            <c>divs: [<div>Two</div>]</c>
            </para>
            </remarks>
            <param name="query">the selector query whose results should be removed from these elements
            </param>
            <returns>a new elements list that contains only the filtered results</returns>
        </member>
        <member name="M:Supremes.Nodes.Elements.Eq(System.Int32)">
            <summary>
            Get the <i>nth</i> matched element as an Elements object.
            </summary>
            <remarks>
            See also
            <see>this[int]</see>
            to retrieve an Element.
            </remarks>
            <param name="index">the (zero-based) index of the element in the list to retain</param>
            <returns>
            Elements containing only the specified element, or, if that element did not exist, an empty list.
            </returns>
        </member>
        <member name="M:Supremes.Nodes.Elements.Is(System.String)">
            <summary>
            Test if any of the matched elements match the supplied query.
            </summary>
            <param name="query">A selector</param>
            <returns>true if at least one element in the list matches the query.</returns>
        </member>
        <member name="P:Supremes.Nodes.Elements.Parents">
            <summary>
            Get all of the parents and ancestor elements of the matched elements.
            </summary>
            <returns>all of the parents and ancestor elements of the matched elements</returns>
        </member>
        <member name="P:Supremes.Nodes.Elements.First">
            <summary>
            Get the first matched element.
            </summary>
            <returns>The first matched element, or <c>null</c> if contents is empty.</returns>
        </member>
        <member name="P:Supremes.Nodes.Elements.Last">
            <summary>
            Get the last matched element.
            </summary>
            <returns>The last matched element, or <c>null</c> if contents is empty.</returns>
        </member>
        <member name="M:Supremes.Nodes.Elements.Traverse(Supremes.Select.INodeVisitor)">
            <summary>
            Perform a depth-first traversal on each of the selected elements.
            </summary>
            <param name="nodeVisitor">the visitor callbacks to perform on each node</param>
            <returns>this, for chaining</returns>
        </member>
        <member name="P:Supremes.Nodes.Elements.Forms">
            <summary>
            Get the
            <see cref="T:Supremes.Nodes.FormElement">FormElement</see>
            forms from the selected elements, if any.
            </summary>
            <returns>
            a list of
            <see cref="T:Supremes.Nodes.FormElement">FormElement</see>
            s pulled from the matched elements. The list will be empty if the elements contain
            no forms.
            </returns>
        </member>
        <member name="P:Supremes.Nodes.Elements.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:Supremes.Nodes.Elements" />.
            </summary>
        </member>
        <member name="M:Supremes.Nodes.Elements.Contains(System.Object)">
            <summary>
            Determines whether the <see cref="T:Supremes.Nodes.Elements" /> contains a specific value.
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Supremes.Nodes.Elements.GetEnumerator">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Supremes.Nodes.Elements.Add(Supremes.Nodes.Element)">
            <summary>
            Adds an item to the <see cref="T:Supremes.Nodes.Elements" />.
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Supremes.Nodes.Elements.Remove(Supremes.Nodes.Element)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:Supremes.Nodes.Elements" />.
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:Supremes.Nodes.Elements.Clear">
            <summary>
            Removes all items from the <see cref="T:Supremes.Nodes.Elements" />.
            </summary>
        </member>
        <member name="M:Supremes.Nodes.Elements.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:Supremes.Nodes.Elements"/> instances for equality.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Supremes.Nodes.Elements.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Supremes.Nodes.Elements.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
        </member>
        <member name="M:Supremes.Nodes.Elements.Insert(System.Int32,Supremes.Nodes.Element)">
            <summary>
            Inserts an item to the <see cref="T:Supremes.Nodes.Elements" />
            at the specified index.
            </summary>
            <param name="index"></param>
            <param name="element"></param>
        </member>
        <member name="M:Supremes.Nodes.Elements.RemoveAt(System.Int32)">
            <summary>
            Removes the <see cref="T:Supremes.Nodes.Elements" /> item at the specified index.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Supremes.Nodes.Elements.IndexOf(Supremes.Nodes.Element)">
            <summary>
            Determines the index of a specific item in the <see cref="T:Supremes.Nodes.Elements" />.
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="T:Supremes.Nodes.FormElement">
            <summary>
            A HTML Form Element provides ready access to the form fields/controls that are associated with it.
            </summary>
            <remarks>
            It also allows a form to easily be submitted.
            </remarks>
        </member>
        <member name="M:Supremes.Nodes.FormElement.#ctor(Supremes.Nodes.Tag,System.String,Supremes.Nodes.Attributes)">
            <summary>
            Create a new, standalone form element.
            </summary>
            <param name="tag">tag of this element</param>
            <param name="baseUri">the base URI</param>
            <param name="attributes">initial attributes</param>
        </member>
        <member name="P:Supremes.Nodes.FormElement.Elements">
            <summary>
            Get the list of form control elements associated with this form.
            </summary>
            <returns>form controls associated with this element.</returns>
        </member>
        <member name="M:Supremes.Nodes.FormElement.AddElement(Supremes.Nodes.Element)">
            <summary>
            Add a form control element to this form.
            </summary>
            <param name="element">form control to add</param>
            <returns>this form element, for chaining</returns>
        </member>
        <member name="M:Supremes.Nodes.FormElement.SubmitAsync(System.Net.Http.HttpClient)">
            <summary>
            submit this form, using a specified HttpClient.
            </summary>
            <remarks>
            the request will be set up from the form values.
            You can set up other options (like user-agent, timeout, cookies) before executing.
            </remarks>
            <returns>an async task.</returns>
            <exception cref="T:System.ArgumentException">
            if the form's absolute action URL cannot be determined.
            Make sure you pass the document's base URI when parsing.
            </exception>
        </member>
        <member name="M:Supremes.Nodes.FormElement.SubmitAsync(System.Net.Http.HttpClient,System.Threading.CancellationToken)">
            <summary>
            submit this form, using a specified HttpClient.
            </summary>
            <remarks>
            the request will be set up from the form values.
            You can set up other options (like user-agent, timeout, cookies) before executing.
            </remarks>
            <returns>an async task.</returns>
            <exception cref="T:System.ArgumentException">
            if the form's absolute action URL cannot be determined.
            Make sure you pass the document's base URI when parsing.
            </exception>
        </member>
        <member name="P:Supremes.Nodes.FormElement.FormData">
            <summary>
            Get the data that this form submits.
            </summary>
            <remarks>
            The returned list is a copy of the data, and changes to the contents of the
            list will not be reflected in the DOM.
            </remarks>
            <returns>a list of key vals</returns>
        </member>
        <member name="T:Supremes.Nodes.Node">
            <summary>
            The base, abstract Node model.
            </summary>
            <remarks>
            Elements, Documents, Comments etc are all Node instances.
            </remarks>
            <author>Jonathan Hedley, jonathan@hedley.net</author>
        </member>
        <member name="M:Supremes.Nodes.Node.#ctor(System.String,Supremes.Nodes.Attributes)">
            <summary>
            Create a new Node.
            </summary>
            <param name="baseUri">base URI</param>
            <param name="attributes">attributes (not null, but may be empty)</param>
        </member>
        <member name="M:Supremes.Nodes.Node.#ctor">
            <summary>
            Default constructor.
            </summary>
            <remarks>
            Doesn't setup base uri, children, or attributes; use with caution.
            </remarks>
        </member>
        <member name="P:Supremes.Nodes.Node.NodeName">
            <summary>
            Get the node name of this node.
            </summary>
            <remarks>
            Use for debugging purposes and not logic switching (for that, use instanceof).
            </remarks>
            <returns>node name</returns>
        </member>
        <member name="M:Supremes.Nodes.Node.Attr(System.String)">
            <summary>
            Get an attribute's value by its key.
            </summary>
            <remarks>
            To get an absolute URL from an attribute that may be a relative URL, prefix the key with <c><b>abs</b></c>,
            which is a shortcut to the
            <see cref="M:Supremes.Nodes.Node.AbsUrl(System.String)">AbsUrl(string)</see>
            method.
            E.g.: <blockquote><c>String url = a.attr("abs:href");</c></blockquote>
            </remarks>
            <param name="attributeKey">The attribute key.</param>
            <returns>The attribute, or empty string if not present (to avoid nulls).</returns>
            <seealso cref="P:Supremes.Nodes.Node.Attributes">Attributes</seealso>
            <seealso cref="M:Supremes.Nodes.Node.HasAttr(System.String)">HasAttr(string)</seealso>
            <seealso cref="M:Supremes.Nodes.Node.AbsUrl(System.String)">AbsUrl(string)</seealso>
        </member>
        <member name="P:Supremes.Nodes.Node.Attributes">
            <summary>
            Get all of the element's attributes.
            </summary>
            <returns>
            attributes (which implements iterable, in same order as presented in original HTML).
            </returns>
        </member>
        <member name="M:Supremes.Nodes.Node.Attr(System.String,System.String)">
            <summary>
            Set an attribute (key=value).
            </summary>
            <remarks>
            If the attribute already exists, it is replaced.
            </remarks>
            <param name="attributeKey">The attribute key.</param>
            <param name="attributeValue">The attribute value.</param>
            <returns>this (for chaining)</returns>
        </member>
        <member name="M:Supremes.Nodes.Node.HasAttr(System.String)">
            <summary>
            Test if this element has an attribute.
            </summary>
            <param name="attributeKey">The attribute key to check.</param>
            <returns>true if the attribute exists, false if not.</returns>
        </member>
        <member name="M:Supremes.Nodes.Node.RemoveAttr(System.String)">
            <summary>
            Remove an attribute from this element.
            </summary>
            <param name="attributeKey">The attribute to remove.</param>
            <returns>this (for chaining)</returns>
        </member>
        <member name="P:Supremes.Nodes.Node.BaseUri">
            <summary>
            Get or Set the base URI of this node.
            When set, it updates the base URI of this node and all of its descendants.
            </summary>
            <value>base URI to set</value>
            <returns>base URI</returns>
        </member>
        <member name="M:Supremes.Nodes.Node.AbsUrl(System.String)">
            <summary>
            Get an absolute URL from a URL attribute that may be relative
            (i.e. an <c>&lt;a href&gt;</c> or <c>&lt;img src&gt;</c>).
            </summary>
            <remarks>
            <para>
            E.g.: <c>string absUrl = linkEl.AbsUrl("href");</c>
            </para>
            <para>
            If the attribute value is already absolute (i.e. it starts with a protocol, like
            <c>http://</c> or <c>https://</c> etc), and it successfully parses as a URL, the attribute is
            returned directly. Otherwise, it is treated as a URL relative to the element's
            <see cref="P:Supremes.Nodes.Node.BaseUri">BaseUri</see>
            , and made
            absolute using that.
            </para>
            <para>
            As an alternate, you can use the
            <see cref="M:Supremes.Nodes.Node.Attr(System.String)">Attr(string)</see>
            method with the <c>abs:</c> prefix, e.g.:
            <c>string absUrl = linkEl.Attr("abs:href");</c>
            </para>
            <para>
            This method add trailing slash to domain name: i.e.
            from <c>&lt;a id=2 href='http://jsoup.org'&gt;</c>
            to <c>"http://jsoup.org/"</c>
            </para>
            </remarks>
            <param name="attributeKey">The attribute key</param>
            <returns>
            An absolute URL if one could be made, or an empty string (not null) if the attribute was missing or
            could not be made successfully into a URL.
            </returns>
            <seealso cref="M:Supremes.Nodes.Node.Attr(System.String)">Attr(string)</seealso>
            <seealso cref="M:System.Uri.TryCreate(System.String,System.UriKind,System.Uri@)">System.Uri.TryCreate(string,UriKind,out Uri)</seealso>
        </member>
        <member name="M:Supremes.Nodes.Node.ChildNode(System.Int32)">
            <summary>
            Get a child node by its 0-based index.
            </summary>
            <param name="index">index of child node</param>
            <returns>
            the child node at this index. Throws a
            <c>IndexOutOfBoundsException</c>
            if the index is out of bounds.
            </returns>
        </member>
        <member name="P:Supremes.Nodes.Node.ChildNodes">
            <summary>
            Get this node's children.
            </summary>
            <remarks>
            Presented as an unmodifiable list: new children can not be added, but the child nodes
            themselves can be manipulated.
            </remarks>
            <returns>list of children. If no children, returns an empty list.</returns>
        </member>
        <member name="M:Supremes.Nodes.Node.ChildNodesCopy">
            <summary>
            Returns a deep copy of this node's children.
            </summary>
            <remarks>
            Changes made to these nodes will not be reflected in the original nodes
            </remarks>
            <returns>a deep copy of this node's children</returns>
        </member>
        <member name="P:Supremes.Nodes.Node.ChildNodeSize">
            <summary>
            Get the number of child nodes that this node holds.
            </summary>
            <returns>the number of child nodes that this node holds.</returns>
        </member>
        <member name="P:Supremes.Nodes.Node.Parent">
            <summary>
            Gets this node's parent node.
            </summary>
            <returns>parent node; or null if no parent.</returns>
        </member>
        <member name="P:Supremes.Nodes.Node.OwnerDocument">
            <summary>
            Gets the Document associated with this Node.
            </summary>
            <returns>
            the Document associated with this Node, or null if there is no such Document.
            </returns>
        </member>
        <member name="M:Supremes.Nodes.Node.Remove">
            <summary>
            Remove (delete) this node from the DOM tree.
            </summary>
            <remarks>
            If this node has children, they are also removed.
            </remarks>
        </member>
        <member name="M:Supremes.Nodes.Node.Before(System.String)">
            <summary>
            Insert the specified HTML into the DOM before this node (i.e. as a preceding sibling).
            </summary>
            <param name="html">HTML to add before this node</param>
            <returns>this node, for chaining</returns>
            <seealso cref="M:Supremes.Nodes.Node.After(System.String)">After(string)</seealso>
        </member>
        <member name="M:Supremes.Nodes.Node.Before(Supremes.Nodes.Node)">
            <summary>
            Insert the specified node into the DOM before this node (i.e. as a preceding sibling).
            </summary>
            <param name="node">to add before this node</param>
            <returns>this node, for chaining</returns>
            <seealso cref="M:Supremes.Nodes.Node.After(Supremes.Nodes.Node)">After(Node)</seealso>
        </member>
        <member name="M:Supremes.Nodes.Node.After(System.String)">
            <summary>
            Insert the specified HTML into the DOM after this node (i.e. as a following sibling).
            </summary>
            <param name="html">HTML to add after this node</param>
            <returns>this node, for chaining</returns>
            <seealso cref="M:Supremes.Nodes.Node.Before(System.String)">Before(string)</seealso>
        </member>
        <member name="M:Supremes.Nodes.Node.After(Supremes.Nodes.Node)">
            <summary>
            Insert the specified node into the DOM after this node (i.e. as a following sibling).
            </summary>
            <param name="node">to add after this node</param>
            <returns>this node, for chaining</returns>
            <seealso cref="M:Supremes.Nodes.Node.Before(Supremes.Nodes.Node)">Before(Node)</seealso>
        </member>
        <member name="M:Supremes.Nodes.Node.Wrap(System.String)">
            <summary>
            Wrap the supplied HTML around this node.
            </summary>
            <param name="html">
            HTML to wrap around this element, e.g.
            <c><![CDATA[<div class="head"></div>]]></c>
            . Can be arbitrarily deep.
            </param>
            <returns>this node, for chaining.</returns>
        </member>
        <member name="M:Supremes.Nodes.Node.Unwrap">
            <summary>
            Removes this node from the DOM, and moves its children up into the node's parent.
            </summary>
            <remarks>
            This has the effect of dropping the node but keeping its children.
            <p/>
            For example, with the input html:<br/>
            <c><![CDATA[<div>One <span>Two <b>Three</b></span></div>]]></c>
            <br/>
            Calling
            <c>element.Unwrap()</c>
            on the
            <c>span</c>
            element will result in the html:<br/>
            <c><![CDATA[<div>One Two <b>Three</b></div>]]></c>
            <br/>
            and the
            <c>"Two "</c>
            <see cref="T:Supremes.Nodes.TextNode">TextNode</see>
            being returned.
            </remarks>
            <returns>
            the first child of this node, after the node has been unwrapped. Null if the node had no children.
            </returns>
            <seealso cref="M:Supremes.Nodes.Node.Remove">Remove()</seealso>
            <seealso cref="M:Supremes.Nodes.Node.Wrap(System.String)">Wrap(string)</seealso>
        </member>
        <member name="M:Supremes.Nodes.Node.ReplaceWith(Supremes.Nodes.Node)">
            <summary>
            Replace this node in the DOM with the supplied node.
            </summary>
            <param name="in">the node that will will replace the existing node.</param>
        </member>
        <member name="P:Supremes.Nodes.Node.SiblingNodes">
            <summary>
            Retrieves this node's sibling nodes.
            </summary>
            <remarks>
            Similar to
            <see cref="P:Supremes.Nodes.Node.ChildNodes">node.parent.ChildNodes</see>
            , but does not
            include this node (a node is not a sibling of itself).
            </remarks>
            <returns>node siblings. If the node has no parent, returns an empty list.</returns>
        </member>
        <member name="P:Supremes.Nodes.Node.NextSibling">
            <summary>
            Get this node's next sibling.
            </summary>
            <returns>next sibling, or null if this is the last sibling</returns>
        </member>
        <member name="P:Supremes.Nodes.Node.PreviousSibling">
            <summary>
            Get this node's previous sibling.
            </summary>
            <returns>the previous sibling, or null if this is the first sibling</returns>
        </member>
        <member name="P:Supremes.Nodes.Node.SiblingIndex">
            <summary>
            Get the list index of this node in its node sibling list.
            </summary>
            <remarks>
            I.e. if this is the first node sibling, returns 0.
            </remarks>
            <returns>position in node sibling list</returns>
            <seealso cref="P:Supremes.Nodes.Element.ElementSiblingIndex">Element.ElementSiblingIndex</seealso>
        </member>
        <member name="M:Supremes.Nodes.Node.Traverse(Supremes.Select.INodeVisitor)">
            <summary>
            Perform a depth-first traversal through this node and its descendants.
            </summary>
            <param name="nodeVisitor">the visitor callbacks to perform on each node</param>
            <returns>this node, for chaining</returns>
        </member>
        <member name="P:Supremes.Nodes.Node.OuterHtml">
            <summary>
            Get the outer HTML of this node.
            </summary>
            <returns>HTML</returns>
        </member>
        <member name="M:Supremes.Nodes.Node.AppendOuterHtmlHeadTo(System.Text.StringBuilder,System.Int32,Supremes.Nodes.DocumentOutputSettings)">
            <summary>
            Get the outer HTML of this node.
            </summary>
            <param name="accum">accumulator to place HTML into</param>
            <param name="depth"></param>
            <param name="out"></param>
        </member>
        <member name="M:Supremes.Nodes.Node.ToString">
            <summary>
            Converts the value of this instance to a string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Supremes.Nodes.Node.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:Supremes.Nodes.Node"/> instances for equality.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Supremes.Nodes.Node.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Supremes.Nodes.Node.Clone">
            <summary>
            Create a stand-alone, deep copy of this node, and all of its children.
            </summary>
            <remarks>
            The cloned node will have no siblings or parent node.
            As a stand-alone object, any changes made to the clone or any of its children
            will not impact the original node.
            <p/>
            The cloned node may be adopted into another Document or node structure using
            <see cref="M:Supremes.Nodes.Element.AppendChild(Supremes.Nodes.Node)">Element.AppendChild(Node)</see>
            .
            </remarks>
            <returns>stand-alone cloned node</returns>
        </member>
        <member name="T:Supremes.Nodes.Tag">
            <summary>
            HTML Tag capabilities.
            </summary>
            <author>Jonathan Hedley, jonathan@hedley.net</author>
        </member>
        <member name="P:Supremes.Nodes.Tag.Name">
            <summary>
            Get this tag's name.
            </summary>
            <returns>the tag's name</returns>
        </member>
        <member name="M:Supremes.Nodes.Tag.ValueOf(System.String)">
            <summary>
            Get a Tag by name.
            </summary>
            <remarks>
            If not previously defined (unknown), returns a new generic tag, that can do anything.
            <p/>
            Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals().
            </remarks>
            <param name="tagName">Name of tag, e.g. "p". Case insensitive.</param>
            <returns>The tag, either defined or new generic.</returns>
        </member>
        <member name="P:Supremes.Nodes.Tag.IsBlock">
            <summary>
            Gets if this is a block tag.
            </summary>
            <returns>if block tag</returns>
        </member>
        <member name="P:Supremes.Nodes.Tag.IsFormattedAsBlock">
            <summary>
            Gets if this tag should be formatted as a block (or as inline)
            </summary>
            <returns>if should be formatted as block or inline</returns>
        </member>
        <member name="P:Supremes.Nodes.Tag.CanContainBlock">
            <summary>
            Gets if this tag can contain block tags.
            </summary>
            <returns>if tag can contain block tags</returns>
        </member>
        <member name="P:Supremes.Nodes.Tag.IsInline">
            <summary>
            Gets if this tag is an inline tag.
            </summary>
            <returns>if this tag is an inline tag.</returns>
        </member>
        <member name="P:Supremes.Nodes.Tag.IsData">
            <summary>
            Gets if this tag is a data only tag.
            </summary>
            <returns>if this tag is a data only tag</returns>
        </member>
        <member name="P:Supremes.Nodes.Tag.IsEmpty">
            <summary>
            Get if this is an empty tag
            </summary>
            <returns>if this is an empty tag</returns>
        </member>
        <member name="P:Supremes.Nodes.Tag.IsSelfClosing">
            <summary>
            Get if this tag is self closing.
            </summary>
            <returns>if this tag should be output as self closing.</returns>
        </member>
        <member name="P:Supremes.Nodes.Tag.IsKnown">
            <summary>
            Get if this is a pre-defined tag, or was auto created on parsing.
            </summary>
            <returns>if a known tag</returns>
        </member>
        <member name="M:Supremes.Nodes.Tag.IsKnownTag(System.String)">
            <summary>
            Check if this tagname is a known tag.
            </summary>
            <param name="tagName">name of tag</param>
            <returns>if known HTML tag</returns>
        </member>
        <member name="P:Supremes.Nodes.Tag.PreservesWhitespace">
            <summary>
            Get if this tag should preserve whitespace within child text nodes.
            </summary>
            <returns>if preserve whitepace</returns>
        </member>
        <member name="P:Supremes.Nodes.Tag.IsFormListed">
            <summary>
            Get if this tag represents a control associated with a form.
            </summary>
            <remarks>
            E.g. input, textarea, output
            </remarks>
            <returns>if associated with a form</returns>
        </member>
        <member name="P:Supremes.Nodes.Tag.IsFormSubmittable">
            <summary>
            Get if this tag represents an element that should be submitted with a form.
            </summary>
            <remarks>
            E.g. input, option
            </remarks>
            <returns>if submittable with a form</returns>
        </member>
        <member name="M:Supremes.Nodes.Tag.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:Supremes.Nodes.Tag"/> instances for equality.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Supremes.Nodes.Tag.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Supremes.Nodes.Tag.ToString">
            <summary>
            Converts the value of this instance to a string.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Supremes.Nodes.TextNode">
            <summary>
            A text node.
            </summary>
            <author>Jonathan Hedley, jonathan@hedley.net</author>
        </member>
        <member name="M:Supremes.Nodes.TextNode.#ctor(System.String,System.String)">
            <summary>
            Create a new TextNode representing the supplied (unencoded) text).
            </summary>
            <param name="text">raw text</param>
            <param name="baseUri">base uri</param>
            <seealso cref="M:Supremes.Nodes.TextNode.CreateFromEncoded(System.String,System.String)">CreateFromEncoded(string, string)
            </seealso>
        </member>
        <member name="P:Supremes.Nodes.TextNode.Text">
            <summary>
            Get or Set text content of this text node.
            </summary>
            <remarks>
            <para>
            if you want to use fluent API, write <c>using Supremes.Fluent;</c>.
            </para>
            </remarks>
            <value>unencoded text</value>
            <returns>Unencoded, normalised text.</returns>
            <seealso cref="P:Supremes.Nodes.TextNode.WholeText">TextNode.WholeText</seealso>
            <seealso cref="T:Supremes.Fluent.FluentUtility">Supremes.Fluent.FluentUtility</seealso>
        </member>
        <member name="P:Supremes.Nodes.TextNode.WholeText">
            <summary>
            Get the (unencoded) text of this text node, including any newlines and spaces present in the original.
            </summary>
            <returns>text</returns>
        </member>
        <member name="P:Supremes.Nodes.TextNode.IsBlank">
            <summary>
            Test if this text node is blank -- that is, empty or only whitespace (including newlines).
            </summary>
            <returns>true if this document is empty or only whitespace, false if it contains any text content.
            </returns>
        </member>
        <member name="M:Supremes.Nodes.TextNode.SplitText(System.Int32)">
            <summary>
            Split this text node into two nodes at the specified string offset.
            </summary>
            <remarks>
            After splitting, this node will contain the
            original text up to the offset, and will have a new text node sibling containing the text after the offset.
            </remarks>
            <param name="offset">string offset point to split node at.</param>
            <returns>the newly created text node containing the text after the offset.</returns>
        </member>
        <member name="M:Supremes.Nodes.TextNode.ToString">
            <summary>
            Converts the value of this instance to a string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Supremes.Nodes.TextNode.CreateFromEncoded(System.String,System.String)">
            <summary>
            Create a new TextNode from HTML encoded (aka escaped) data.
            </summary>
            <param name="encodedText">Text containing encoded HTML (e.g. &amp;lt;)</param>
            <param name="baseUri">base URI</param>
            <returns>TextNode containing unencoded data (e.g. &lt;)</returns>
        </member>
        <member name="M:Supremes.Nodes.TextNode.Attr(System.String)">
            <summary>
            Get an attribute's value by its key.
            </summary>
            <param name="attributeKey"></param>
            <returns></returns>
        </member>
        <member name="P:Supremes.Nodes.TextNode.Attributes">
            <summary>
            Get all of the element's attributes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Supremes.Nodes.TextNode.Attr(System.String,System.String)">
            <summary>
            Set an attribute (key=value).
            </summary>
            <param name="attributeKey"></param>
            <param name="attributeValue"></param>
            <returns></returns>
        </member>
        <member name="M:Supremes.Nodes.TextNode.HasAttr(System.String)">
            <summary>
            Test if this element has an attribute.
            </summary>
            <param name="attributeKey"></param>
            <returns></returns>
        </member>
        <member name="M:Supremes.Nodes.TextNode.RemoveAttr(System.String)">
            <summary>
            Remove an attribute from this element.
            </summary>
            <param name="attributeKey"></param>
            <returns></returns>
        </member>
        <member name="M:Supremes.Nodes.TextNode.AbsUrl(System.String)">
            <summary>
            Get an absolute URL from a URL attribute that may be relative.
            </summary>
            <param name="attributeKey">The attribute key</param>
            <returns></returns>
        </member>
        <member name="T:Supremes.Nodes.XmlDeclaration">
            <summary>
            An XML Declaration.
            </summary>
            <author>Jonathan Hedley, jonathan@hedley.net</author>
        </member>
        <member name="M:Supremes.Nodes.XmlDeclaration.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Create a new XML declaration
            </summary>
            <param name="data">data</param>
            <param name="baseUri">base uri</param>
            <param name="isProcessingInstruction">is processing instruction</param>
        </member>
        <member name="P:Supremes.Nodes.XmlDeclaration.WholeDeclaration">
            <summary>
            Get the unencoded XML declaration.
            </summary>
            <returns>XML declaration</returns>
        </member>
        <member name="M:Supremes.Nodes.XmlDeclaration.ToString">
            <summary>
            Converts the value of this instance to a string.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Supremes.Parsers.CharacterReader">
            <summary>
            CharacterReader consumes tokens off a string.
            </summary>
            <remarks>
            To replace the old TokenQueue.
            </remarks>
        </member>
        <member name="M:Supremes.Parsers.CharacterReader.NextIndexOf(System.Char)">
            <summary>
            Returns the number of characters between the current position and the next instance of the input char
            </summary>
            <param name="c">scan target</param>
            <returns>
            offset between current position and next instance of target. -1 if not found.
            </returns>
        </member>
        <member name="M:Supremes.Parsers.CharacterReader.NextIndexOf(System.String)">
            <summary>
            Returns the number of characters between the current position and the next instance of the input sequence
            </summary>
            <param name="seq">scan target</param>
            <returns>
            offset between current position and next instance of target. -1 if not found.
            </returns>
        </member>
        <member name="T:Supremes.Parsers.DataUtil">
            <summary>
            Internal static utilities for handling data.
            </summary>
        </member>
        <member name="M:Supremes.Parsers.DataUtil.Load(System.String,System.String,System.String)">
            <summary>
            Loads a file to a Document.
            </summary>
            <param name="in">file to load</param>
            <param name="charsetName">character set of input</param>
            <param name="baseUri">base URI of document, to resolve relative links against</param>
            <returns>Document</returns>
            <exception cref="T:System.IO.IOException">on IO error</exception>
        </member>
        <member name="M:Supremes.Parsers.DataUtil.Load(System.IO.Stream,System.String,System.String)">
            <summary>
            Parses a Document from an input steam.
            </summary>
            <param name="in">input stream to parse. You will need to close it.</param>
            <param name="charsetName">character set of input</param>
            <param name="baseUri">base URI of document, to resolve relative links against</param>
            <returns>Document</returns>
            <exception cref="T:System.IO.IOException">on IO error</exception>
        </member>
        <member name="M:Supremes.Parsers.DataUtil.Load(System.IO.Stream,System.String,System.String,Supremes.Parsers.Parser)">
            <summary>
            Parses a Document from an input steam, using the provided Parser.
            </summary>
            <param name="in">input stream to parse. You will need to close it.</param>
            <param name="charsetName">character set of input</param>
            <param name="baseUri">base URI of document, to resolve relative links against</param>
            <param name="parser">
            alternate
            <see cref="P:Supremes.Parsers.Parser.XmlParser">parser</see>
            to use.
            </param>
            <returns>Document</returns>
            <exception cref="T:System.IO.IOException">on IO error</exception>
        </member>
        <member name="M:Supremes.Parsers.DataUtil.ReadToByteBuffer(System.IO.Stream,System.Int32)">
            <summary>
            Read the input stream into a byte buffer.
            </summary>
            <param name="inStream">the input stream to read from</param>
            <param name="maxSize">
            the maximum size in bytes to read from the stream. Set to 0 to be unlimited.
            </param>
            <returns>the filled byte buffer</returns>
            <exception cref="T:System.IO.IOException">if an exception occurs whilst reading from the input stream.
            </exception>
        </member>
        <member name="M:Supremes.Parsers.DataUtil.ReadToByteBuffer(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Supremes.Parsers.DataUtil.ReadFileToByteBuffer(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Supremes.Parsers.DataUtil.GetCharsetFromContentType(System.String)">
            <summary>
            Parse out a charset from a content type header.
            </summary>
            <remarks>
            regardless of whether the charset is not supported or not.
            </remarks>
            <param name="contentType">e.g. "text/html; charset=EUC-JP"</param>
            <returns>"EUC-JP", or null if not found. Charset is trimmed and uppercased.</returns>
        </member>
        <member name="T:Supremes.Parsers.HtmlTreeBuilder">
            <summary>
            HTML Tree Builder; creates a DOM from Tokens.
            </summary>
        </member>
        <member name="M:Supremes.Parsers.HtmlTreeBuilder.GenerateImpliedEndTags(System.String)">
            <summary>
            11.2.5.2 Closing elements that have implied end tags<p/>
            When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a
            dt element, an li element, an option element, an optgroup element, a p element, an rp element, or an rt element,
            the UA must pop the current node off the stack of open elements.
            </summary>
            <remarks>
            11.2.5.2 Closing elements that have implied end tags<p/>
            When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a
            dt element, an li element, an option element, an optgroup element, a p element, an rp element, or an rt element,
            the UA must pop the current node off the stack of open elements.
            </remarks>
            <param name="excludeTag">
            If a step requires the UA to generate implied end tags but lists an element to exclude from the
            process, then the UA must perform the above steps as if that element was not in the above list.
            </param>
        </member>
        <member name="T:Supremes.Parsers.HtmlTreeBuilderState">
            <summary>
            The Tree Builder's current state.
            </summary>
            <remarks>
            Each state embodies the processing for the state, and transitions to other states.
            </remarks>
        </member>
        <member name="T:Supremes.Parsers.ParseError">
            <summary>
            A Parse Error records an error in the input HTML that occurs in either the tokenisation or the tree building phase.
            </summary>
        </member>
        <member name="P:Supremes.Parsers.ParseError.ErrorMessage">
            <summary>
            Retrieve the error message.
            </summary>
            <returns>the error message.</returns>
        </member>
        <member name="P:Supremes.Parsers.ParseError.Position">
            <summary>
            Retrieves the offset of the error.
            </summary>
            <returns>error offset within input</returns>
        </member>
        <member name="M:Supremes.Parsers.ParseError.ToString">
            <summary>
            Converts the value of this instance to a string.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Supremes.Parsers.ParseErrorList">
            <summary>
            A container for ParseErrors.
            </summary>
            <author>Jonathan Hedley</author>
        </member>
        <member name="T:Supremes.Parsers.Parser">
            <summary>
            Parses HTML into a
            <see cref="T:Supremes.Nodes.Document">Supremes.Nodes.Document</see>
            . Generally best to use one of the  more convenient parse methods
            in
            <see cref="T:Supremes.Dcsoup">Supremes.Dcsoup</see>
            .
            </summary>
        </member>
        <member name="M:Supremes.Parsers.Parser.#ctor(Supremes.Parsers.TreeBuilder)">
            <summary>
            Create a new Parser, using the specified TreeBuilder
            </summary>
            <param name="treeBuilder">TreeBuilder to use to parse input into Documents.</param>
        </member>
        <member name="M:Supremes.Parsers.Parser.ParseInput(System.String,System.String)">
            <summary>
            Parse HTML into a Document
            </summary>
            <param name="html"></param>
            <param name="baseUri"></param>
            <returns></returns>
        </member>
        <member name="P:Supremes.Parsers.Parser.TreeBuilder">
            <summary>
            Get the TreeBuilder currently in use.
            </summary>
            <returns>current TreeBuilder.</returns>
        </member>
        <member name="M:Supremes.Parsers.Parser.SetTreeBuilder(Supremes.Parsers.TreeBuilder)">
            <summary>
            Update the TreeBuilder used when parsing content.
            </summary>
            <param name="treeBuilder">current TreeBuilder</param>
            <returns>this, for chaining</returns>
        </member>
        <member name="P:Supremes.Parsers.Parser.CanTrackErrors">
            <summary>
            Check if parse error tracking is enabled.
            </summary>
            <returns>current track error state.</returns>
        </member>
        <member name="M:Supremes.Parsers.Parser.SetTrackErrors(System.Int32)">
            <summary>
            Enable or disable parse error tracking for the next parse.
            </summary>
            <param name="maxErrors">
            the maximum number of errors to track. Set to 0 to disable.
            </param>
            <returns>this, for chaining</returns>
        </member>
        <member name="P:Supremes.Parsers.Parser.Errors">
            <summary>
            Retrieve the parse errors, if any, from the last parse.
            </summary>
            <returns>list of parse errors, up to the size of the maximum errors tracked.</returns>
        </member>
        <member name="P:Supremes.Parsers.Parser.HtmlParser">
            <summary>
            Create a new HTML parser.
            </summary>
            <remarks>
            This parser treats input as HTML5, and enforces the creation of a normalised document,
            based on a knowledge of the semantics of the incoming tags.
            </remarks>
            <returns>a new HTML parser.</returns>
        </member>
        <member name="P:Supremes.Parsers.Parser.XmlParser">
            <summary>
            Create a new XML parser.
            </summary>
            <remarks>
            This parser assumes no knowledge of the incoming tags and does not treat it as HTML,
            rather creates a simple tree directly from the input.
            </remarks>
            <returns>a new simple XML parser.</returns>
        </member>
        <member name="M:Supremes.Parsers.Parser.Parse(System.String,System.String)">
            <summary>
            Parse HTML into a Document.
            </summary>
            <param name="html">HTML to parse</param>
            <param name="baseUri">base URI of document (i.e. original fetch location), for resolving relative URLs.</param>
            <returns>parsed Document</returns>
        </member>
        <member name="M:Supremes.Parsers.Parser.ParseFragment(System.String,Supremes.Nodes.Element,System.String)">
            <summary>
            Parse a fragment of HTML into a list of nodes.
            </summary>
            <remarks>
            The context element, if supplied, supplies parsing context.
            </remarks>
            <param name="fragmentHtml">the fragment of HTML to parse</param>
            <param name="context">
            (optional) the element that this HTML fragment is being parsed for (i.e. for inner HTML). This
            provides stack context (for implicit element creation).
            </param>
            <param name="baseUri">
            base URI of document (i.e. original fetch location), for resolving relative URLs.
            </param>
            <returns>
            list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modified.
            </returns>
        </member>
        <member name="M:Supremes.Parsers.Parser.ParseXmlFragment(System.String,System.String)">
            <summary>
            Parse a fragment of XML into a list of nodes.
            </summary>
            <param name="fragmentXml">the fragment of XML to parse</param>
            <param name="baseUri">base URI of document (i.e. original fetch location), for resolving relative URLs.</param>
            <returns>list of nodes parsed from the input XML.</returns>
        </member>
        <member name="M:Supremes.Parsers.Parser.ParseBodyFragment(System.String,System.String)">
            <summary>
            Parse a fragment of HTML into the
            <c>body</c>
            of a Document.
            </summary>
            <param name="bodyHtml">fragment of HTML</param>
            <param name="baseUri">base URI of document (i.e. original fetch location), for resolving relative URLs.</param>
            <returns>Document, with empty head, and HTML parsed into body</returns>
        </member>
        <member name="M:Supremes.Parsers.Parser.UnescapeEntities(System.String,System.Boolean)">
            <summary>
            Utility method to unescape HTML entities from a string
            </summary>
            <param name="string">HTML escaped string</param>
            <param name="inAttribute">if the string is to be escaped in strict mode (as attributes are)</param>
            <returns>an unescaped string</returns>
        </member>
        <member name="T:Supremes.Parsers.Token">
            <summary>
            Parse tokens for the Tokeniser.
            </summary>
        </member>
        <member name="T:Supremes.Parsers.Tokeniser">
            <summary>
            Readers the input stream into tokens.
            </summary>
        </member>
        <member name="M:Supremes.Parsers.Tokeniser.UnescapeEntities(System.Boolean)">
            <summary>
            Utility method to consume reader and unescape entities found within.
            </summary>
            <param name="inAttribute"></param>
            <returns>unescaped string from reader</returns>
        </member>
        <member name="T:Supremes.Parsers.TokeniserState">
            <summary>
            States and transition activations for the Tokeniser.
            </summary>
        </member>
        <member name="M:Supremes.Parsers.TokeniserState._TokeniserState_42.Read(Supremes.Parsers.Tokeniser,Supremes.Parsers.CharacterReader)">
            handles data in title, textarea etc
        </member>
        <member name="M:Supremes.Parsers.TokeniserState.HandleDataEndTag(Supremes.Parsers.Tokeniser,Supremes.Parsers.CharacterReader,Supremes.Parsers.TokeniserState)">
            <summary>
            Handles RawtextEndTagName, ScriptDataEndTagName, and ScriptDataEscapedEndTagName.
            </summary>
            <remarks>
            Handles RawtextEndTagName, ScriptDataEndTagName, and ScriptDataEscapedEndTagName. Same body impl, just
            different else exit transitions.
            </remarks>
        </member>
        <member name="T:Supremes.Parsers.TreeBuilder">
            <author>Jonathan Hedley</author>
        </member>
        <member name="T:Supremes.Parsers.XmlTreeBuilder">
            <summary>
            Use the
            <c>XmlTreeBuilder</c>
            when you want to parse XML without any of the HTML DOM rules being applied to the
            document.
            <p>Usage example:
            <c>Document xmlDoc = Nsoup.Parse(html, baseUrl, Parser.XmlParser());</c>
            </p>
            </summary>
            <author>Jonathan Hedley</author>
        </member>
        <member name="M:Supremes.Parsers.XmlTreeBuilder.PopStackToClose(Supremes.Parsers.Token.EndTag)">
            <summary>
            If the stack contains an element with this tag's name, pop up the stack to remove the first occurrence.
            </summary>
            <remarks>
            If not found, skips.
            </remarks>
            <param name="endTag"></param>
        </member>
        <member name="T:Supremes.Safety.Cleaner">
            <summary>
            The whitelist based HTML cleaner.
            </summary>
            <remarks>
            The whitelist based HTML cleaner. Use to ensure that end-user provided HTML contains only the elements and attributes
            that you are expecting; no junk, and no cross-site scripting attacks!
            <p/>
            The HTML cleaner parses the input as HTML and then runs it through a white-list, so the output HTML can only contain
            HTML that is allowed by the whitelist.
            <p/>
            It is assumed that the input HTML is a body fragment; the clean methods only pull from the source's body, and the
            canned white-lists only allow body contained tags.
            <p/>
            Rather than interacting directly with a Cleaner object, generally see the
            <c>Clean</c>
            methods in
            <see cref="T:Supremes.Dcsoup">Supremes.Dcsoup</see>
            .
            </remarks>
        </member>
        <member name="M:Supremes.Safety.Cleaner.#ctor(Supremes.Safety.Whitelist)">
            <summary>
            Create a new cleaner, that sanitizes documents using the supplied whitelist.
            </summary>
            <param name="whitelist">white-list to clean with</param>
        </member>
        <member name="M:Supremes.Safety.Cleaner.Clean(Supremes.Nodes.Document)">
            <summary>
            Creates a new, clean document, from the original dirty document,
            containing only elements allowed by the whitelist.
            </summary>
            <remarks>
            The original document is not modified.
            Only elements from the dirt document's <c>body</c> are used.
            </remarks>
            <param name="dirtyDocument">Untrusted base document to clean.</param>
            <returns>cleaned document.</returns>
        </member>
        <member name="M:Supremes.Safety.Cleaner.IsValid(Supremes.Nodes.Document)">
            <summary>
            Determines if the input document is valid, against the whitelist.
            </summary>
            <remarks>
            It is considered valid if all the tags and attributes
            in the input HTML are allowed by the whitelist.
            <p/>
            This method can be used as a validator for user input forms.
            An invalid document will still be cleaned successfully
            using the
            <see cref="M:Supremes.Safety.Cleaner.Clean(Supremes.Nodes.Document)">Clean(Supremes.Nodes.Document)</see>
            document. If using as a validator, it is recommended to still clean the document
            to ensure enforced attributes are set correctly, and that the output is tidied.
            </remarks>
            <param name="dirtyDocument">document to test</param>
            <returns>true if no tags or attributes need to be removed; false if they do</returns>
        </member>
        <member name="T:Supremes.Safety.Cleaner.CleaningVisitor">
            <summary>
            Iterates the input and copies trusted nodes (tags, attributes, text)
            into the destination.
            </summary>
        </member>
        <member name="T:Supremes.Safety.Whitelist">
            <summary>
            Whitelists define what HTML (elements and attributes) to allow through the cleaner.
            </summary>
            <remarks>
            Everything else is removed.
            <p/>
            Start with one of the defaults:
            <ul>
            <li>
            <see cref="P:Supremes.Safety.Whitelist.None">None</see>
            </li>
            <li>
            <see cref="P:Supremes.Safety.Whitelist.SimpleText">SimpleText</see>
            </li>
            <li>
            <see cref="P:Supremes.Safety.Whitelist.Basic">Basic</see>
            </li>
            <li>
            <see cref="P:Supremes.Safety.Whitelist.BasicWithImages">BasicWithImages</see>
            </li>
            <li>
            <see cref="P:Supremes.Safety.Whitelist.Relaxed">Relaxed</see>
            </li>
            </ul>
            <p/>
            If you need to allow more through (please be careful!), tweak a base whitelist with:
            <ul>
            <li>
            <see cref="M:Supremes.Safety.Whitelist.AddTags(System.String[])">AddTags(string[])</see>
            </li>
            <li>
            <see cref="M:Supremes.Safety.Whitelist.AddAttributes(System.String,System.String[])">AddAttributes(string, string[])</see>
            </li>
            <li>
            <see cref="M:Supremes.Safety.Whitelist.AddEnforcedAttribute(System.String,System.String,System.String)">AddEnforcedAttribute(string, string, string)
            </see>
            </li>
            <li>
            <see cref="M:Supremes.Safety.Whitelist.AddProtocols(System.String,System.String,System.String[])">AddProtocols(string, string, string[])
            </see>
            </li>
            </ul>
            <p/>
            The cleaner and these whitelists assume that you want to clean a <c>body</c> fragment of HTML (to add user
            supplied HTML into a templated page), and not to clean a full HTML document. If the latter is the case, either wrap the
            document HTML around the cleaned body HTML, or create a whitelist that allows <c>html</c> and <c>head</c>
            elements as appropriate.
            <p/>
            If you are going to extend a whitelist, please be very careful. Make sure you understand what attributes may lead to
            XSS attack vectors. URL attributes are particularly vulnerable and require careful validation. See
            http://ha.ckers.org/xss.html for some XSS attack examples.
            </remarks>
            <author>Jonathan Hedley</author>
        </member>
        <member name="P:Supremes.Safety.Whitelist.None">
            <summary>
            This whitelist allows only text nodes: all HTML will be stripped.
            </summary>
            <returns>whitelist</returns>
        </member>
        <member name="P:Supremes.Safety.Whitelist.SimpleText">
            <summary>
            This whitelist allows only simple text formatting: <c>b, em, i, strong, u</c>.
            </summary>
            <remarks>
            All other HTML (tags and attributes) will be removed.
            </remarks>
            <returns>whitelist</returns>
        </member>
        <member name="P:Supremes.Safety.Whitelist.Basic">
            <summary>
            This whitelist allows a fuller range of text nodes: <c>a, b, blockquote, br, cite, code, dd, dl, dt, em, i, li,
            ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul</c>, and appropriate attributes.
            </summary>
            <remarks>
            <para>
            Links (<c>a</c> elements) can point to <c>http, https, ftp, mailto</c>, and have an enforced
            <c>rel=nofollow</c> attribute.
            </para>
            <para>
            Does not allow images.
            </para>
            </remarks>
            <returns>whitelist</returns>
        </member>
        <member name="P:Supremes.Safety.Whitelist.BasicWithImages">
            <summary>
            This whitelist allows the same text tags as
            <see cref="P:Supremes.Safety.Whitelist.Basic">Basic</see>
            , and also allows <c>img</c> tags, with appropriate
            attributes, with <c>src</c> pointing to <c>http</c> or <c>https</c>.
            </summary>
            <returns>whitelist</returns>
        </member>
        <member name="P:Supremes.Safety.Whitelist.Relaxed">
            <summary>
            This whitelist allows a full range of text and structural body HTML: <c>a, b, blockquote, br, caption, cite,
            code, col, colgroup, dd, div, dl, dt, em, h1, h2, h3, h4, h5, h6, i, img, li, ol, p, pre, q, small, span, strike, strong, sub,
            sup, table, tbody, td, tfoot, th, thead, tr, u, ul</c>
            <p/>
            Links do not have an enforced <c>rel=nofollow</c> attribute, but you can add that if desired.
            </summary>
            <remarks>
            This whitelist allows a full range of text and structural body HTML: <c>a, b, blockquote, br, caption, cite,
            code, col, colgroup, dd, div, dl, dt, em, h1, h2, h3, h4, h5, h6, i, img, li, ol, p, pre, q, small, span, strike, strong, sub,
            sup, table, tbody, td, tfoot, th, thead, tr, u, ul</c>
            <p/>
            Links do not have an enforced <c>rel=nofollow</c> attribute, but you can add that if desired.
            </remarks>
            <returns>whitelist</returns>
        </member>
        <member name="M:Supremes.Safety.Whitelist.#ctor">
            <summary>
            Create a new, empty whitelist.</summary>
            <remarks>
            Generally it will be better to start with a default prepared whitelist instead.
            </remarks>
            <seealso cref="P:Supremes.Safety.Whitelist.Basic">Basic</seealso>
            <seealso cref="P:Supremes.Safety.Whitelist.BasicWithImages">BasicWithImages</seealso>
            <seealso cref="P:Supremes.Safety.Whitelist.SimpleText">SimpleText</seealso>
            <seealso cref="P:Supremes.Safety.Whitelist.Relaxed">Relaxed</seealso>
        </member>
        <member name="M:Supremes.Safety.Whitelist.AddTags(System.String[])">
            <summary>
            Add a list of allowed elements to a whitelist.</summary>
            <remarks>
            (If a tag is not allowed, it will be removed from the HTML.)
            </remarks>
            <param name="tags">tag names to allow</param>
            <returns>this (for chaining)</returns>
        </member>
        <member name="M:Supremes.Safety.Whitelist.AddAttributes(System.String,System.String[])">
            <summary>
            Add a list of allowed attributes to a tag.
            </summary>
            <remarks>
            (If an attribute is not allowed on an element, it will be removed.)
            <p/>
            E.g.: <c>addAttributes("a", "href", "class")</c> allows <c>href</c> and <c>class</c> attributes
            on <c>a</c> tags.
            <p/>
            To make an attribute valid for <b>all tags</b>, use the pseudo tag <c>:all</c>, e.g.
            <c>addAttributes(":all", "class")</c>.
            </remarks>
            <param name="tag">The tag the attributes are for. The tag will be added to the allowed tag list if necessary.
            </param>
            <param name="keys">List of valid attributes for the tag</param>
            <returns>this (for chaining)</returns>
        </member>
        <member name="M:Supremes.Safety.Whitelist.AddEnforcedAttribute(System.String,System.String,System.String)">
            <summary>
            Add an enforced attribute to a tag.
            </summary>
            <remarks>
            An enforced attribute will always be added to the element. If the element
            already has the attribute set, it will be overridden.
            <p/>
            E.g.: <c>AddEnforcedAttribute("a", "rel", "nofollow")</c> will make all <c>a</c> tags output as
            <c>&lt;a href="..." rel="nofollow"&gt;</c>
            </remarks>
            <param name="tag">The tag the enforced attribute is for. The tag will be added to the allowed tag list if necessary.
            </param>
            <param name="key">The attribute key</param>
            <param name="value">The enforced attribute value</param>
            <returns>this (for chaining)</returns>
        </member>
        <member name="M:Supremes.Safety.Whitelist.PreserveRelativeLinks(System.Boolean)">
            <summary>
            Configure this Whitelist to preserve relative links in an element's URL attribute, or convert them to absolute
            links.
            </summary>
            <remarks>
            Configure this Whitelist to preserve relative links in an element's URL attribute, or convert them to absolute
            links. By default, this is <b>false</b>: URLs will be  made absolute (e.g. start with an allowed protocol, like
            e.g.
            <c>http://</c>
            .
            <p />
            Note that when handling relative links, the input document must have an appropriate
            <c>base URI</c>
            set when
            parsing, so that the link's protocol can be confirmed. Regardless of the setting of the
            <c>
            preserve relative
            links
            </c>
            option, the link must be resolvable against the base URI to an allowed protocol; otherwise the attribute
            will be removed.
            </remarks>
            <param name="preserve">
            
            <c>true</c>
            to allow relative links,
            <c>false</c>
            (default) to deny
            </param>
            <returns>this Whitelist, for chaining.</returns>
            <seealso cref="M:Supremes.Safety.Whitelist.AddProtocols(System.String,System.String,System.String[])">AddProtocols(string, string, string[])
            </seealso>
        </member>
        <member name="M:Supremes.Safety.Whitelist.AddProtocols(System.String,System.String,System.String[])">
            <summary>
            Add allowed URL protocols for an element's URL attribute.
            </summary>
            <remarks>
            This restricts the possible values of the attribute to
            URLs with the defined protocol.
            <p/>
            E.g.: <c>AddProtocols("a", "href", "ftp", "http", "https")</c>
            </remarks>
            <param name="tag">Tag the URL protocol is for</param>
            <param name="key">Attribute key</param>
            <param name="protocols">List of valid protocols</param>
            <returns>this, for chaining</returns>
        </member>
        <member name="M:Supremes.Safety.Whitelist.IsSafeTag(System.String)">
            <summary>
            Test if the supplied tag is allowed by this whitelist
            </summary>
            <param name="tag">test tag</param>
            <returns>true if allowed</returns>
        </member>
        <member name="M:Supremes.Safety.Whitelist.IsSafeAttribute(System.String,Supremes.Nodes.Element,Supremes.Nodes.Attribute)">
            <summary>
            Test if the supplied attribute is allowed by this whitelist for this tag
            </summary>
            <param name="tagName">tag to consider allowing the attribute in</param>
            <param name="el">element under test, to confirm protocol</param>
            <param name="attr">attribute under test</param>
            <returns>true if allowed</returns>
        </member>
        <member name="T:Supremes.Select.Collector">
            <summary>
            Collects a list of elements that match the supplied criteria.
            </summary>
            <author>Jonathan Hedley</author>
        </member>
        <member name="M:Supremes.Select.Collector.Collect(Supremes.Select.Evaluator,Supremes.Nodes.Element)">
            <summary>
            Build a list of elements,
            by visiting root and every descendant of root, and testing it against the evaluator.
            </summary>
            <param name="eval">Evaluator to test elements against</param>
            <param name="root">root of tree to descend</param>
            <returns>list of matches; empty if none</returns>
        </member>
        <member name="T:Supremes.Select.CombiningEvaluator">
            <summary>
            Base combining (and, or) evaluator.
            </summary>
        </member>
        <member name="M:Supremes.Select.CombiningEvaluator.Or.#ctor(System.Collections.Generic.ICollection{Supremes.Select.Evaluator})">
            <summary>
            Create a new Or evaluator.
            </summary>
            <remarks>
            The initial evaluators are ANDed together and used as the first clause of the OR.
            </remarks>
            <param name="evaluators">initial OR clause (these are wrapped into an AND evaluator).</param>
        </member>
        <member name="T:Supremes.Select.Evaluator">
            <summary>
            Evaluates that an element matches the selector.
            </summary>
        </member>
        <member name="M:Supremes.Select.Evaluator.Matches(Supremes.Nodes.Element,Supremes.Nodes.Element)">
            <summary>
            Test if the element meets the evaluator's requirements.
            </summary>
            <param name="root">Root of the matching subtree</param>
            <param name="element">tested element</param>
        </member>
        <member name="T:Supremes.Select.Evaluator.Tag">
            <summary>
            Evaluator for tag name
            </summary>
        </member>
        <member name="T:Supremes.Select.Evaluator.ID">
            <summary>
            Evaluator for element id
            </summary>
        </member>
        <member name="T:Supremes.Select.Evaluator.Class">
            <summary>
            Evaluator for element class
            </summary>
        </member>
        <member name="T:Supremes.Select.Evaluator.Attribute">
            <summary>
            Evaluator for attribute name matching
            </summary>
        </member>
        <member name="T:Supremes.Select.Evaluator.AttributeStarting">
            <summary>
            Evaluator for attribute name prefix matching
            </summary>
        </member>
        <member name="T:Supremes.Select.Evaluator.AttributeWithValue">
            <summary>
            Evaluator for attribute name/value matching
            </summary>
        </member>
        <member name="T:Supremes.Select.Evaluator.AttributeWithValueNot">
            <summary>
            Evaluator for attribute name != value matching
            </summary>
        </member>
        <member name="T:Supremes.Select.Evaluator.AttributeWithValueStarting">
            <summary>
            Evaluator for attribute name/value matching (value prefix)
            </summary>
        </member>
        <member name="T:Supremes.Select.Evaluator.AttributeWithValueEnding">
            <summary>
            Evaluator for attribute name/value matching (value ending)
            </summary>
        </member>
        <member name="T:Supremes.Select.Evaluator.AttributeWithValueContaining">
            <summary>
            Evaluator for attribute name/value matching (value containing)
            </summary>
        </member>
        <member name="T:Supremes.Select.Evaluator.AttributeWithValueMatching">
            <summary>
            Evaluator for attribute name/value matching (value regex matching)
            </summary>
        </member>
        <member name="T:Supremes.Select.Evaluator.AttributeKeyPair">
            <summary>
            Abstract evaluator for attribute name/value matching
            </summary>
        </member>
        <member name="T:Supremes.Select.Evaluator.AllElements">
            <summary>
            Evaluator for any / all element matching
            </summary>
        </member>
        <member name="T:Supremes.Select.Evaluator.IndexLessThan">
            <summary>
            Evaluator for matching by sibling index number (e &lt; idx)
            </summary>
        </member>
        <member name="T:Supremes.Select.Evaluator.IndexGreaterThan">
            <summary>
            Evaluator for matching by sibling index number (e &gt; idx)
            </summary>
        </member>
        <member name="T:Supremes.Select.Evaluator.IndexEquals">
            <summary>
            Evaluator for matching by sibling index number (e = idx)
            </summary>
        </member>
        <member name="T:Supremes.Select.Evaluator.IsLastChild">
            <summary>
            Evaluator for matching the last sibling (css :last-child)
            </summary>
        </member>
        <member name="T:Supremes.Select.Evaluator.IsNthChild">
            <summary>
            css-compatible Evaluator for :eq (css :nth-child)
            </summary>
            <seealso cref="T:Supremes.Select.Evaluator.IndexEquals">IndexEquals</seealso>
        </member>
        <member name="T:Supremes.Select.Evaluator.IsNthLastChild">
            <summary>
            css pseudo class :nth-last-child)
            </summary>
            <seealso cref="T:Supremes.Select.Evaluator.IndexEquals">IndexEquals</seealso>
        </member>
        <member name="T:Supremes.Select.Evaluator.IsNthOfType">
            <summary>
            css pseudo class nth-of-type
            </summary>
        </member>
        <member name="T:Supremes.Select.Evaluator.IsFirstChild">
            <summary>
            Evaluator for matching the first sibling (css :first-child)
            </summary>
        </member>
        <member name="T:Supremes.Select.Evaluator.IsRoot">
            <summary>
            css3 pseudo-class :root
            </summary>
            <seealso><a href="http://www.w3.org/TR/selectors/#root-pseudo">:root selector</a></seealso>
        </member>
        <member name="T:Supremes.Select.Evaluator.IndexEvaluator">
            <summary>
            Abstract evaluator for sibling index matching
            </summary>
            <author>ant</author>
        </member>
        <member name="T:Supremes.Select.Evaluator.ContainsText">
            <summary>
            Evaluator for matching Element (and its descendants) text
            </summary>
        </member>
        <member name="T:Supremes.Select.Evaluator.ContainsOwnText">
            <summary>
            Evaluator for matching Element's own text
            </summary>
        </member>
        <member name="T:Supremes.Select.Evaluator.MatchesText">
            <summary>
            Evaluator for matching Element (and its descendants) text with regex
            </summary>
        </member>
        <member name="T:Supremes.Select.Evaluator.MatchesOwnText">
            <summary>
            Evaluator for matching Element's own text with regex
            </summary>
        </member>
        <member name="T:Supremes.Select.INodeVisitor">
            <summary>
            Node visitor interface.
            </summary>
            <remarks>
            Provide an implementing class to
            <see cref="T:Supremes.Select.NodeTraversor">NodeTraversor</see>
            to iterate through nodes.
            <p/>
            This interface provides two methods,
            <c>head</c>
            and
            <c>tail</c>
            . The head method is called when the node is first
            seen, and the tail method when all of the node's children have been visited. As an example, head can be used to
            create a start tag for a node, and tail to create the end tag.
            </remarks>
        </member>
        <member name="M:Supremes.Select.INodeVisitor.Head(Supremes.Nodes.Node,System.Int32)">
            <summary>
            Callback for when a node is first visited.
            </summary>
            <param name="node">the node being visited.</param>
            <param name="depth">
            the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node
            of that will have depth 1.
            </param>
        </member>
        <member name="M:Supremes.Select.INodeVisitor.Tail(Supremes.Nodes.Node,System.Int32)">
            <summary>
            Callback for when a node is last visited, after all of its descendants have been visited.
            </summary>
            <param name="node">the node being visited.</param>
            <param name="depth">
            the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node
            of that will have depth 1.
            </param>
        </member>
        <member name="T:Supremes.Select.NodeTraversor">
            <summary>
            Depth-first node traversor.
            </summary>
            <remarks>
            Depth-first node traversor. Use to iterate through all nodes under and including the specified root node.
            <p/>
            This implementation does not use recursion, so a deep DOM does not risk blowing the stack.
            </remarks>
        </member>
        <member name="M:Supremes.Select.NodeTraversor.#ctor(Supremes.Select.INodeVisitor)">
            <summary>
            Create a new traversor.
            </summary>
            <param name="visitor">
            a class implementing the
            <see cref="T:Supremes.Select.INodeVisitor">INodeVisitor</see>
            interface, to be called when visiting each node.
            </param>
        </member>
        <member name="M:Supremes.Select.NodeTraversor.Traverse(Supremes.Nodes.Node)">
            <summary>
            Start a depth-first traverse of the root and all of its descendants.
            </summary>
            <param name="root">the root node point to traverse.</param>
        </member>
        <member name="T:Supremes.Select.QueryParser">
            <summary>
            Parses a CSS selector into an Evaluator tree.
            </summary>
        </member>
        <member name="M:Supremes.Select.QueryParser.#ctor(System.String)">
            <summary>
            Create a new QueryParser.
            </summary>
            <param name="query">CSS query</param>
        </member>
        <member name="M:Supremes.Select.QueryParser.Parse(System.String)">
            <summary>
            Parse a CSS query into an Evaluator.
            </summary>
            <param name="query">CSS query</param>
            <returns>Evaluator</returns>
        </member>
        <member name="M:Supremes.Select.QueryParser.Parse">
            <summary>
            Parse the query
            </summary>
            <returns>Evaluator</returns>
        </member>
        <member name="T:Supremes.Select.Selector">
            <summary>
            CSS-like element selector, that finds elements matching a query.
            </summary>
            <remarks>
            <para>
            <h2>Selector syntax</h2>
            A selector is a chain of simple selectors, separated by combinators. Selectors are case insensitive (including against
            elements, attributes, and attribute values).
            </para>
            <para>
            The universal selector (*) is implicit when no element selector is supplied (i.e.
            <c>*.header</c>
            and
            <c>.header</c>
            is equivalent).
            </para>
            <para>
            <table>
                 <tr><th align="left">Pattern</th><th align="left">Matches</th><th align="left">Example</th></tr>
                 <tr><td><c>*</c></td><td>any element</td><td><c>*</c></td></tr>
                 <tr><td><c>tag</c></td><td>elements with the given tag name</td><td><c>div</c></td></tr>
                 <tr><td><c>ns|E</c></td><td>elements of type E in the namespace <i>ns</i></td><td><c>fb|name</c> finds <c>&lt;fb:name&gt;</c> elements</td></tr>
                 <tr><td><c>#id</c></td><td>elements with attribute ID of "id"</td><td><c>div#wrap</c>, <c>#logo</c></td></tr>
                 <tr><td><c>.class</c></td><td>elements with a class name of "class"</td><td><c>div.left</c>, <c>.result</c></td></tr>
                 <tr><td><c>[attr]</c></td><td>elements with an attribute named "attr" (with any value)</td><td><c>a[href]</c>, <c>[title]</c></td></tr>
                 <tr><td><c>[^attrPrefix]</c></td><td>elements with an attribute name starting with "attrPrefix". Use to find elements with HTML5 datasets</td><td><c>[^data-]</c>, <c>div[^data-]</c></td></tr>
                 <tr><td><c>[attr=val]</c></td><td>elements with an attribute named "attr", and value equal to "val"</td><td><c>img[width=500]</c>, <c>a[rel=nofollow]</c></td></tr>
                 <tr><td><c>[attr=&quot;val&quot;]</c></td><td>elements with an attribute named "attr", and value equal to "val"</td><td><c>span[hello="Cleveland"][goodbye="Columbus"]</c>, <c>a[rel=&quot;nofollow&quot;]</c></td></tr>
                 <tr><td><c>[attr^=valPrefix]</c></td><td>elements with an attribute named "attr", and value starting with "valPrefix"</td><td><c>a[href^=http:]</c></td></tr>
                 <tr><td><c>[attr$=valSuffix]</c></td><td>elements with an attribute named "attr", and value ending with "valSuffix"</td><td><c>img[src$=.png]</c></td></tr>
                 <tr><td><c>[attr*=valContaining]</c></td><td>elements with an attribute named "attr", and value containing "valContaining"</td><td><c>a[href*=/search/]</c></td></tr>
                 <tr><td><c>[attr~=<em>regex</em>]</c></td><td>elements with an attribute named "attr", and value matching the regular expression</td><td><c>img[src~=(?i)\\.(png|jpe?g)]</c></td></tr>
                 <tr><td></td><td>The above may be combined in any order</td><td><c>div.header[title]</c></td></tr>
                 <tr><td colspan="3"><h3>Combinators</h3></td></tr>
                 <tr><td><c>E F</c></td><td>an F element descended from an E element</td><td><c>div a</c>, <c>.logo h1</c></td></tr>
                 <tr><td><c>E &gt; F</c></td><td>an F direct child of E</td><td><c>ol &gt; li</c></td></tr>
                 <tr><td><c>E + F</c></td><td>an F element immediately preceded by sibling E</td><td><c>li + li</c>, <c>div.head + div</c></td></tr>
                 <tr><td><c>E ~ F</c></td><td>an F element preceded by sibling E</td><td><c>h1 ~ p</c></td></tr>
                 <tr><td><c>E, F, G</c></td><td>all matching elements E, F, or G</td><td><c>a[href], div, h3</c></td></tr>
                 <tr><td colspan="3"><h3>Pseudo selectors</h3></td></tr>
                 <tr><td><c>:lt(<em>n</em>)</c></td><td>elements whose sibling index is less than <em>n</em></td><td><c>td:lt(3)</c> finds the first 2 cells of each row</td></tr>
                 <tr><td><c>:gt(<em>n</em>)</c></td><td>elements whose sibling index is greater than <em>n</em></td><td><c>td:gt(1)</c> finds cells after skipping the first two</td></tr>
                 <tr><td><c>:eq(<em>n</em>)</c></td><td>elements whose sibling index is equal to <em>n</em></td><td><c>td:eq(0)</c> finds the first cell of each row</td></tr>
                 <tr><td><c>:has(<em>selector</em>)</c></td><td>elements that contains at least one element matching the <em>selector</em></td><td><c>div:has(p)</c> finds divs that contain p elements </td></tr>
                 <tr><td><c>:not(<em>selector</em>)</c></td><td>elements that do not match the <em>selector</em>. See also
                 <see cref="M:Supremes.Nodes.Elements.Not(System.String)">Supremes.Nodes.Elements.Not(string)</see>
                 </td><td><c>div:not(.logo)</c> finds all divs that do not have the "logo" class.<br /><c>div:not(:has(div))</c> finds divs that do not contain divs.</td></tr>
                 <tr><td><c>:contains(<em>text</em>)</c></td><td>elements that contains the specified text. The search is case insensitive. The text may appear in the found element, or any of its descendants.</td><td><c>p:contains(jsoup)</c> finds p elements containing the text "jsoup".</td></tr>
                 <tr><td><c>:matches(<em>regex</em>)</c></td><td>elements whose text matches the specified regular expression. The text may appear in the found element, or any of its descendants.</td><td><c>td:matches(\\d+)</c> finds table cells containing digits. <c>div:matches((?i)login)</c> finds divs containing the text, case insensitively.</td></tr>
                 <tr><td><c>:containsOwn(<em>text</em>)</c></td><td>elements that directly contain the specified text. The search is case insensitive. The text must appear in the found element, not any of its descendants.</td><td><c>p:containsOwn(jsoup)</c> finds p elements with own text "jsoup".</td></tr>
                 <tr><td><c>:matchesOwn(<em>regex</em>)</c></td><td>elements whose own text matches the specified regular expression. The text must appear in the found element, not any of its descendants.</td><td><c>td:matchesOwn(\\d+)</c> finds table cells directly containing digits. <c>div:matchesOwn((?i)login)</c> finds divs containing the text, case insensitively.</td></tr>
                 <tr><td></td><td>The above may be combined in any order and with other selectors</td><td><c>.light:contains(name):eq(0)</c></td></tr>
                 <tr><td colspan="3"><h3>Structural pseudo selectors</h3></td></tr>
                 <tr><td><c>:root</c></td><td>The element that is the root of the document. In HTML, this is the <c>html</c> element</td><td><c>:root</c></td></tr>
                 <tr><td><c>:nth-child(<em>a</em>n+<em>b</em>)</c></td><td><p>elements that have <c><em>a</em>n+<em>b</em>-1</c> siblings <b>before</b> it in the document tree, for any positive integer or zero value of <c>n</c>, and has a parent element. For values of <c>a</c> and <c>b</c> greater than zero, this effectively divides the element's children into groups of a elements (the last group taking the remainder), and selecting the <em>b</em>th element of each group. For example, this allows the selectors to address every other row in a table, and could be used to alternate the color of paragraph text in a cycle of four. The <c>a</c> and <c>b</c> values must be integers (positive, negative, or zero). The index of the first child of an element is 1.</p>
                 In addition to this, <c>:nth-child()</c> can take <c>odd</c> and <c>even</c> as arguments instead. <c>odd</c> has the same signification as <c>2n+1</c>, and <c>even</c> has the same signification as <c>2n</c>.</td><td><c>tr:nth-child(2n+1)</c> finds every odd row of a table. <c>:nth-child(10n-1)</c> the 9th, 19th, 29th, etc, element. <c>li:nth-child(5)</c> the 5h li</td></tr>
                 <tr><td><c>:nth-last-child(<em>a</em>n+<em>b</em>)</c></td><td>elements that have <c><em>a</em>n+<em>b</em>-1</c> siblings <b>after</b> it in the document tree. Otherwise like <c>:nth-child()</c></td><td><c>tr:nth-last-child(-n+2)</c> the last two rows of a table</td></tr>
                 <tr><td><c>:nth-of-type(<em>a</em>n+<em>b</em>)</c></td><td>pseudo-class notation represents an element that has <c><em>a</em>n+<em>b</em>-1</c> siblings with the same expanded element name <em>before</em> it in the document tree, for any zero or positive integer value of n, and has a parent element</td><td><c>img:nth-of-type(2n+1)</c></td></tr>
                 <tr><td><c>:nth-last-of-type(<em>a</em>n+<em>b</em>)</c></td><td>pseudo-class notation represents an element that has <c><em>a</em>n+<em>b</em>-1</c> siblings with the same expanded element name <em>after</em> it in the document tree, for any zero or positive integer value of n, and has a parent element</td><td><c>img:nth-last-of-type(2n+1)</c></td></tr>
                 <tr><td><c>:first-child</c></td><td>elements that are the first child of some other element.</td><td><c>div &gt; p:first-child</c></td></tr>
                 <tr><td><c>:last-child</c></td><td>elements that are the last child of some other element.</td><td><c>ol &gt; li:last-child</c></td></tr>
                 <tr><td><c>:first-of-type</c></td><td>elements that are the first sibling of its type in the list of children of its parent element</td><td><c>dl dt:first-of-type</c></td></tr>
                 <tr><td><c>:last-of-type</c></td><td>elements that are the last sibling of its type in the list of children of its parent element</td><td><c>tr &gt; td:last-of-type</c></td></tr>
                 <tr><td><c>:only-child</c></td><td>elements that have a parent element and whose parent element hasve no other element children</td><td></td></tr>
                 <tr><td><c>:only-of-type</c></td><td> an element that has a parent element and whose parent element has no other element children with the same expanded element name</td><td></td></tr>
                 <tr><td><c>:empty</c></td><td>elements that have no children at all</td><td></td></tr>
            </table>
            </para>
            </remarks>
            <author>Jonathan Hedley, jonathan@hedley.net</author>
            <seealso cref="M:Supremes.Nodes.Element.Select(System.String)">Supremes.Nodes.Element.Select(string)</seealso>
        </member>
        <member name="M:Supremes.Select.Selector.Select(System.String,Supremes.Nodes.Element)">
            <summary>
            Find elements matching selector.
            </summary>
            <param name="query">CSS selector</param>
            <param name="root">root element to descend into</param>
            <returns>matching elements, empty if not</returns>
        </member>
        <member name="M:Supremes.Select.Selector.Select(System.String,System.Collections.Generic.IEnumerable{Supremes.Nodes.Element})">
            <summary>
            Find elements matching selector.
            </summary>
            <param name="query">CSS selector</param>
            <param name="roots">root elements to descend into</param>
            <returns>matching elements, empty if not</returns>
        </member>
        <member name="T:Supremes.Select.Selector.SelectorParseException">
            <summary>
            The exception that is thrown when a <see cref="T:Supremes.Select.Selector"/> parses an invalid query.
            </summary>
        </member>
        <member name="M:Supremes.Select.Selector.SelectorParseException.#ctor(System.String,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Supremes.Select.Selector.SelectorParseException"/> class.
            </summary>
            <param name="msg">A composite format string.</param>
            <param name="params">An object array that contains zero or more objects to format.</param>
        </member>
        <member name="T:Supremes.Select.StructuralEvaluator">
            <summary>
            Base structural evaluator.
            </summary>
        </member>
    </members>
</doc>
